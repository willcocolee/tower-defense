<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tower Defense</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
        }

        #enemyCountDisplay {
            position: absolute;
            top: 10px;
            right: 50%;
            transform: translateX(50%);
            color: #ff4444;
            font-family: sans-serif;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        #statsPanel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 41, 59, 0.95);
            padding: 20px;
            border-radius: 8px;
            color: white;
            font-family: sans-serif;
            border: 2px solid #4ade80;
            width: 200px;
            z-index: 99999;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            display: none;
            /* Hidden by default */
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .stat-label {
            color: #94a3b8;
        }

        h2 {
            margin-top: 0;
            font-size: 18px;
            border-bottom: 1px solid #475569;
            padding-bottom: 8px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #ffffff;
            border: none;
            border-radius: 4px;
        }
    </style>
    <!-- Import Three.js module -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">
        <h1>3D Tower Defense</h1>
        <p>Left Click: Place Tower/Select | Right Click: Rotate | Scroll: Zoom</p>
    </div>

    <div id="enemyCountDisplay">Enemies: 0 | Wave: <span id="waveDisplay">1</span></div>

    <div id="statsPanel">
        <h2 id="refName">Tower</h2>
        <div class="stat-row">
            <span class="stat-label">Range</span>
            <span id="refRange">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Damage</span>
            <span id="refDamage">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Cooldown</span>
            <span id="refSpeed">0ms</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Total Kills</span>
            <span id="refKills">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Level</span>
            <span id="refLevel">1</span>
        </div>
        <button id="btnUpgrade"
            style="width: 100%; margin-top: 10px; background: #eab308; color: black; font-weight: bold; cursor: pointer;">UPGRADE</button>
        <button id="btnCloseStats"
            style="width: 100%; margin-top: 10px; font-size: 12px; background: #ef4444; color: white;">Close</button>
    </div>

    <div id="controls">
        <button id="btnStartWave" style="background: #22c55e; color: white;">Start Game</button>
        <div style="width: 20px;"></div>
        <button id="btnBasic" style="border: 2px solid #3b82f6;">Basic</button>
        <button id="btnSniper" style="border: 2px solid #555;">Sniper</button>
        <button id="btnScout" style="border: 2px solid #555;">Scout</button>
        <button id="btnPyro" style="border: 2px solid #555; color: #f97316;">Pyro</button>
        <button id="btnTesla" style="border: 2px solid #555; color: #0ea5e9;">Tesla</button>
        <div style="width: 20px;"></div>
        <button id="btnMusic" style="border: 2px solid #888;">ðŸŽµ Music</button>
    </div>

    <!-- Background Music (Hidden) -->
    <div id="musicContainer" style="display:none;"></div>
    <script>
        // Simple YouTube Player Embed Logic
        // We inject the iframe when button is clicked to bypass some autoplay restrictions cleanly
        const btnMusic = document.getElementById('btnMusic');
        let musicPlaying = false;

        btnMusic.addEventListener('click', () => {
            const container = document.getElementById('musicContainer');
            if (!musicPlaying) {
                container.innerHTML = '<iframe width="1" height="1" src="https://www.youtube.com/embed/vq2AfGYwbE4?autoplay=1&loop=1&playlist=vq2AfGYwbE4" frameborder="0" allow="autoplay"></iframe>';
                musicPlaying = true;
                btnMusic.style.borderColor = '#4ade80'; // Green
                btnMusic.textContent = "ðŸ”Š Music On";
            } else {
                container.innerHTML = '';
                musicPlaying = false;
                btnMusic.style.borderColor = '#888';
                btnMusic.textContent = "ðŸŽµ Music Off";
            }
        });

        // --- SOUND FX ENGINE (Web Audio API) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        // Resume audio context on first user interaction
        window.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }, { once: true });

        function playSound(type) {
            if (audioCtx.state === 'suspended') return;

            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'sniper') {
                // BIG BANG
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);

                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

                osc.start(now);
                osc.stop(now + 0.4);

            } else if (type === 'pyro') {
                // HISS / WHITE NOISE (Simulated with erratic saw)
                // Real noise requires buffer, let's try erratic saw for "fire"
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.1);

                // Quick envelope
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.2);

                osc.start(now);
                osc.stop(now + 0.2);

            } else if (type === 'tesla') {
                // ZAP (High pitch slide)
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.1);

                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

                osc.start(now);
                osc.stop(now + 0.1);

            } else {
                // BASIC PEW
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);

                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

                osc.start(now);
                osc.stop(now + 0.1);
            }
        }
    </script>

    <!-- INLINE SCRIPT TO AVOID CORS ISSUES ON LOCAL FILESYSTEM -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Helper for Range Ring
        function createRangeRing(radius, color) {
            const geometry = new THREE.RingGeometry(radius - 0.2, radius, 64);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.y = 0.1; // Just above ground/road
            return mesh;
        }

        let ghostRing = createRangeRing(1, 0xffffff);

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505); // Darker background for bloom
        scene.fog = new THREE.Fog(0x050505, 20, 60);

        // Isometric view
        const aspect = window.innerWidth / window.innerHeight;
        const d = 60; // Zoom out for larger map
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20);
        camera.lookAt(scene.position);

        // --- REALISTIC RENDERER SETUP ---
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows

        // Tone Mapping & Color Space
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        document.body.appendChild(renderer.domElement);

        // --- POST-PROCESSING ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Bloom: Threshold (0-1), Strength, Radius
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.6; // Only VERY bright things glow
        bloomPass.strength = 0.8;  // Intensity
        bloomPass.radius = 0.5;    // Spread
        composer.addPass(bloomPass);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.maxPolarAngle = Math.PI / 2; // Prevent going under the map

        // Remap controls to standard RTS style
        controls.mouseButtons = {
            LEFT: THREE.MOUSE.PAN,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.ROTATE
        };


        // --- ADVANCED LIGHTING ---
        // 1. Hemisphere Light (Sky/Ground Ambient)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        // 2. Main Sun Directional Light
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); // Higher intensity for tone mapping
        dirLight.position.set(20, 40, 10);
        dirLight.castShadow = true;
        // Shadow properties
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -40;
        dirLight.shadow.camera.right = 40;
        dirLight.shadow.camera.top = 40;
        dirLight.shadow.camera.bottom = -40;
        dirLight.shadow.bias = -0.0005; // Fix shadow acne
        scene.add(dirLight);

        // --- GAME OBJECTS ---
        const TILE_SIZE = 2;
        const MAP_SIZE = 60;
        // Expanded path (5x larger and longer)
        const pathNodes = [
            new THREE.Vector3(-40, 0, -40),
            new THREE.Vector3(-40, 0, 20),
            new THREE.Vector3(-10, 0, 20),
            new THREE.Vector3(-10, 0, -20),
            new THREE.Vector3(20, 0, -20),
            new THREE.Vector3(20, 0, 20),
            new THREE.Vector3(50, 0, 20),
            new THREE.Vector3(50, 0, -50)
        ];

        // Large Ground Plane
        const planeGeom = new THREE.PlaneGeometry(500, 500);
        const planeMat = new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.8 });
        const groundPlane = new THREE.Mesh(planeGeom, planeMat);
        groundPlane.rotation.x = -Math.PI / 2;
        groundPlane.receiveShadow = true;
        scene.add(groundPlane);

        // Function to create road segments
        function createRoad() {
            const roadMat = new THREE.MeshStandardMaterial({
                color: 0x334155,
                roughness: 0.9,
                polygonOffset: true,
                polygonOffsetFactor: -1 // Draw on top of ground
            });

            for (let i = 0; i < pathNodes.length - 1; i++) {
                const start = pathNodes[i];
                const end = pathNodes[i + 1];

                const vec = new THREE.Vector3().subVectors(end, start);
                const length = vec.length();
                const angle = Math.atan2(vec.z, vec.x);

                // Segment mesh (+ extra length to cover corners)
                const geometry = new THREE.PlaneGeometry(length + (TILE_SIZE / 2), TILE_SIZE * 0.8);
                const mesh = new THREE.Mesh(geometry, roadMat);

                // Position at midpoint
                const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                mesh.position.copy(mid);
                mesh.position.y = 0.02; // Slightly above ground
                mesh.rotation.x = -Math.PI / 2;
                mesh.rotation.z = -angle;

                mesh.receiveShadow = true;
                scene.add(mesh);

                // Add rounded corners at nodes? maybe later. Simple rects for now.
            }
        }
        createRoad();


        const towers = [];
        const enemies = [];
        const projectiles = []; // Removed duplicate declaration

        // Tower selection state
        let selectedPlacedTower = null; // Existing tower that is selected for viewing stats

        // --- WAVE SYSTEM VARIABLES ---
        let wave = 1;
        let waveState = 'IDLE'; // IDLE, SPAWNING, ACTIVE, COOLDOWN
        let enemiesToSpawn = 0;
        let spawnTimer = 0;
        let waveCooldown = 0;
        const TIME_BETWEEN_SPAWNS = 40; // ~0.7s
        const TIME_BETWEEN_WAVES = 300; // ~5s

        // --- LOGIC ---

        function spawnEnemy(hpOverride) {
            const geom = new THREE.SphereGeometry(0.6, 16, 16);
            // Color shift based on wave strength (Red -> Purple)
            const hue = Math.max(0, 0.0 + (wave * 0.05));
            const color = new THREE.Color().setHSL(hue > 1 ? 0 : (1 - hue), 1, 0.5);

            const mat = new THREE.MeshLambertMaterial({ color: color });
            const mesh = new THREE.Mesh(geom, mat);

            const start = pathNodes[0];
            mesh.position.copy(start);
            mesh.position.y = 0.6;

            scene.add(mesh);

            // Scale HP with Wave
            const hp = hpOverride || (100 + (wave * 25));

            enemies.push({
                mesh: mesh,
                nodeIndex: 0,
                hp: hp,
                maxHp: hp,
                speed: 0.05 + (wave * 0.005), // Get slightly faster
                active: true
            });
        }

        const btnStartWave = document.getElementById('btnStartWave');
        const waveDisplay = document.getElementById('waveDisplay');

        btnStartWave.addEventListener('click', () => {
            if (waveState === 'IDLE') {
                startWave();
                btnStartWave.style.display = 'none'; // Hide after start, let it run
            }
        });

        function startWave() {
            waveState = 'SPAWNING';
            // Wave Logic: 5 + Wave Index enemies
            enemiesToSpawn = 5 + Math.floor(wave * 1.5);
            spawnTimer = 0;
            waveDisplay.textContent = wave;
            showError(`Wave ${wave} Started!`);
        }

        // Create a small UI for errors
        const errorDiv = document.createElement('div');
        errorDiv.style.position = 'absolute';
        errorDiv.style.top = '50%';
        errorDiv.style.left = '50%';
        errorDiv.style.transform = 'translate(-50%, -50%)';
        errorDiv.style.color = '#ff4444';
        errorDiv.style.fontFamily = 'sans-serif';
        errorDiv.style.fontSize = '24px';
        errorDiv.style.fontWeight = 'bold';
        errorDiv.style.textShadow = '0 0 5px black';
        errorDiv.style.pointerEvents = 'none';
        errorDiv.style.opacity = '0';
        errorDiv.style.transition = 'opacity 0.5s';
        document.body.appendChild(errorDiv);

        function showError(msg) {
            errorDiv.textContent = msg;
            errorDiv.style.opacity = '1';
            setTimeout(() => errorDiv.style.opacity = '0', 1000);
        }

        // DEBUG TOAST (Bottom Right)
        const debugToast = document.createElement('div');
        debugToast.style.position = 'absolute';
        debugToast.style.bottom = '20px';
        debugToast.style.right = '20px';
        debugToast.style.padding = '10px 20px';
        debugToast.style.background = 'rgba(0,0,0,0.8)';
        debugToast.style.color = '#4ade80';
        debugToast.style.fontFamily = 'monospace';
        debugToast.style.fontSize = '16px';
        debugToast.style.borderRadius = '8px';
        debugToast.style.pointerEvents = 'none';
        debugToast.style.transition = 'opacity 0.3s';
        debugToast.style.opacity = '0';
        document.body.appendChild(debugToast);

        let debugMessages = [];
        function showDebug(msg) {
            debugMessages.push(msg);
            if (debugMessages.length > 10) debugMessages.shift(); // Keep last 10
            debugToast.innerHTML = debugMessages.join('<br>');
            debugToast.style.opacity = '1';
        }

        function isPointOnPath(x, z) {
            const point = new THREE.Vector3(x, 0, z);
            const threshold = 0.5; // Radius check (path is effectively 1 unit wide)

            for (let i = 0; i < pathNodes.length - 1; i++) {
                const a = pathNodes[i];
                const b = pathNodes[i + 1];

                // Line segment distance check
                const line = new THREE.Line3(a, b);
                const closest = new THREE.Vector3();
                line.closestPointToPoint(point, true, closest);

                if (closest.distanceTo(point) < threshold) {
                    return true;
                }
            }
            return false;
        }

        const terrainObjects = [];
        let selectedTower = 'basic'; // basic | sniper

        // Terrain Generation
        function generateTerrain() {
            const geom = new THREE.BoxGeometry(TILE_SIZE, 1, TILE_SIZE);
            const mat = new THREE.MeshStandardMaterial({ color: 0x64748b });

            let mountainsSpawned = 0;
            const targetMountains = 2;

            // Try to place mountains
            for (let attempt = 0; attempt < 1000; attempt++) {
                if (mountainsSpawned >= targetMountains) break;

                // Pick a center point
                let cx = Math.floor((Math.random() * 100 - 50) / TILE_SIZE) * TILE_SIZE;
                let cz = Math.floor((Math.random() * 100 - 50) / TILE_SIZE) * TILE_SIZE;

                const radius = 3; // 7x7 area for a wider, nicer hill
                const peakHeight = 10; // Peak height

                // Check constraints for the area
                let validLocation = true;

                // First pass: Validate area
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        const x = cx + (dx * TILE_SIZE);
                        const z = cz + (dz * TILE_SIZE);

                        // 1. Edge Constraint (Must be far from center)
                        if (Math.abs(x) < 35 && Math.abs(z) < 35) {
                            validLocation = false; break;
                        }

                        // 2. Map Bounds
                        if (Math.abs(x) > 65 || Math.abs(z) > 65) {
                            validLocation = false; break;
                        }

                        // 3. Path Safety
                        if (isPointOnPath(x, z)) {
                            validLocation = false; break;
                        }

                        // 4. Overlap Safety (Keep hills distinct for now)
                        if (terrainObjects.some(obj => Math.abs(obj.position.x - x) < 0.1 && Math.abs(obj.position.z - z) < 0.1)) {
                            validLocation = false; break;
                        }
                    }
                    if (!validLocation) break;
                }

                if (!validLocation) continue;

                // Second pass: Spawn blocks in stepped pyramid shape
                mountainsSpawned++;

                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        const x = cx + (dx * TILE_SIZE);
                        const z = cz + (dz * TILE_SIZE);

                        // Calculate height based on distance from center (Manhattan distance for pyramid, or random for noise)
                        // Let's use max(|dx|,|dz|) for concentric square rings (stepped pyramid)
                        const dist = Math.max(Math.abs(dx), Math.abs(dz));

                        // Peak is at dist 0. Height drops by 2 for each step out.
                        let height = peakHeight - (dist * 2);

                        // Optional: Add small random variation to make it look rugged, not perfect steps
                        // if (dist > 0) height += (Math.random() > 0.5 ? 1 : 0);

                        if (height <= 2) continue; // Too low, blend with ground

                        const mesh = new THREE.Mesh(geom, mat);
                        mesh.scale.set(1, height, 1);
                        mesh.position.set(x, height / 2, z);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData = { isTerrain: true, height: height };

                        scene.add(mesh);
                        terrainObjects.push(mesh);
                    }
                }
            }
            console.log("Spawned mountains:", mountainsSpawned);
        }
        generateTerrain(); // Call at startup

        // Tower Selection UI
        const btnBasic = document.getElementById('btnBasic');
        const btnSniper = document.getElementById('btnSniper');
        const btnScout = document.getElementById('btnScout');
        const btnPyro = document.getElementById('btnPyro');
        const btnTesla = document.getElementById('btnTesla');

        btnBasic.addEventListener('click', () => selectTower('basic'));
        btnSniper.addEventListener('click', () => selectTower('sniper'));
        btnScout.addEventListener('click', () => selectTower('scout'));
        btnPyro.addEventListener('click', () => selectTower('pyro'));
        btnTesla.addEventListener('click', () => selectTower('tesla'));

        function selectTower(type) {
            selectedTower = type;
            btnBasic.style.borderColor = type === 'basic' ? '#3b82f6' : '#555';
            btnSniper.style.borderColor = type === 'sniper' ? '#facc15' : '#555';
            btnScout.style.borderColor = type === 'scout' ? '#4ade80' : '#555';
            btnPyro.style.borderColor = type === 'pyro' ? '#f97316' : '#555';
            btnTesla.style.borderColor = type === 'tesla' ? '#0ea5e9' : '#555';
        }

        // Procedural Mesh Generators
        function createScoutMesh() {
            const group = new THREE.Group();

            // Materials
            const matSkin = new THREE.MeshLambertMaterial({ color: 0xfacc15 }); // Yellow
            const matShirt = new THREE.MeshLambertMaterial({ color: 0x3b82f6 }); // Blue
            const matPants = new THREE.MeshLambertMaterial({ color: 0x1e293b }); // Dark Grey
            const matGun = new THREE.MeshLambertMaterial({ color: 0x94a3b8 }); // Grey

            // Legs (combined for simplicity or split)
            const LegL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.5), matPants);
            LegL.position.set(-0.3, 0.6, 0);
            LegL.castShadow = true;
            group.add(LegL);

            const LegR = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.5), matPants);
            LegR.position.set(0.3, 0.6, 0);
            LegR.castShadow = true;
            group.add(LegR);

            // Torso
            const torso = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 0.6), matShirt);
            torso.position.set(0, 1.8, 0);
            torso.castShadow = true;
            group.add(torso);

            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), matSkin);
            head.position.set(0, 2.8, 0);
            head.castShadow = true;
            group.add(head);

            // Cap
            const cap = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.2, 0.85), matShirt);
            cap.position.set(0, 3.25, 0);
            group.add(cap);

            // Arms
            // Left Arm (Down)
            const ArmL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.0, 0.4), matShirt);
            ArmL.position.set(-0.8, 1.8, 0);
            group.add(ArmL);
            const HandL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), matSkin);
            HandL.position.set(-0.8, 1.1, 0);
            group.add(HandL);

            // Right Arm (Raised aiming gun)
            const ArmR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.0, 0.4), matShirt);
            ArmR.position.set(0.8, 1.8, 0.2);
            ArmR.rotation.x = -Math.PI / 2; // Point forward
            group.add(ArmR);
            const HandR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), matSkin);
            HandR.position.set(0.8, 1.8, 0.9); // End of arm
            group.add(HandR);

            // Pistol
            const gunMain = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.8), matGun);
            gunMain.position.set(0.8, 2.0, 1.2);
            group.add(gunMain);
            const gunHandle = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), matGun);
            gunHandle.position.set(0.8, 1.7, 0.9);
            group.add(gunHandle);

            // Face
            const matBlack = new THREE.MeshBasicMaterial({ color: 0x000000 });

            // Eyes
            const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.05), matBlack);
            eyeL.position.set(-0.2, 2.9, 0.41); // Front of face
            group.add(eyeL);

            const eyeR = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.05), matBlack);
            eyeR.position.set(0.2, 2.9, 0.41);
            group.add(eyeR);

            // Mouth (Smile)
            const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.05), matBlack);
            mouth.position.set(0, 2.7, 0.41);
            group.add(mouth);

            // Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.5, 1.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            hitbox.position.set(0, 1.75, 0);
            hitbox.userData = { isHitbox: true };
            group.add(hitbox);

            return group;
        }

        function createSniperMesh() {
            const group = new THREE.Group();

            // Materials
            const matSkin = new THREE.MeshLambertMaterial({ color: 0xffdcb1 }); // Light Skin
            const matClothesDark = new THREE.MeshLambertMaterial({ color: 0x334155 }); // Dark Blue/Grey
            const matClothesLight = new THREE.MeshLambertMaterial({ color: 0x64748b }); // Lighter Grey padding
            const matBlack = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const matGunBody = new THREE.MeshLambertMaterial({ color: 0x94a3b8 }); // Silver/Grey
            const matGlass = new THREE.MeshLambertMaterial({ color: 0xf59e0b }); // Orange/Gold

            // Legs (Wide Stance)
            const LegL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.6), matClothesDark);
            LegL.position.set(-0.4, 0.6, 0);
            LegL.castShadow = true;
            group.add(LegL);

            const LegR = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.6), matClothesDark);
            LegR.position.set(0.4, 0.6, 0);
            LegR.castShadow = true;
            group.add(LegR);

            // Torso
            const torso = new THREE.Mesh(new THREE.BoxGeometry(1.3, 1.2, 0.7), matClothesDark);
            torso.position.set(0, 1.8, 0);
            torso.castShadow = true;
            group.add(torso);

            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), matSkin);
            head.position.set(0, 2.85, 0);
            head.castShadow = true;
            group.add(head);

            // Cap (Backwards/Tactical)
            const cap = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.3, 1.0), matClothesDark);
            cap.position.set(0, 3.3, 0);
            group.add(cap);

            // Headphones
            const phoneL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, 0.4), matBlack);
            phoneL.position.set(-0.5, 2.85, 0);
            group.add(phoneL);
            const phoneR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, 0.4), matBlack);
            phoneR.position.set(0.5, 2.85, 0);
            group.add(phoneR);
            const phoneBand = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.1, 0.2), matBlack);
            phoneBand.position.set(0, 3.35, 0); // On top of cap
            group.add(phoneBand);

            // Sunglasses (Visor)
            const glasses = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.25, 0.1), matGlass);
            glasses.position.set(0, 2.9, 0.46);
            group.add(glasses);

            // Arms (Holding Rifle)
            // Left Arm (Supporting barrel)
            const ArmL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.2, 0.4), matClothesLight);
            ArmL.position.set(-0.6, 2.0, 0.6);
            ArmL.rotation.x = -Math.PI / 2; // Point forward
            ArmL.rotation.z = -0.2; // Angle in
            group.add(ArmL);

            // Right Arm (Trigger)
            const ArmR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.2, 0.4), matClothesLight);
            ArmR.position.set(0.6, 2.0, 0.4);
            ArmR.rotation.x = -Math.PI / 2;
            ArmR.rotation.z = 0.2;
            group.add(ArmR);

            // --- RIFLE ---
            const rifleGroup = new THREE.Group();

            // Main Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 1.5), matGunBody);
            body.position.set(0, 0, 0);
            rifleGroup.add(body);

            // Barrel (Long)
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 2.5, 8), matBlack);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0.1, 2.0);
            rifleGroup.add(barrel);

            // Muzzle Brake
            const muzzle = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.4), matBlack);
            muzzle.position.set(0, 0.1, 3.3);
            rifleGroup.add(muzzle);

            // Scope
            const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.15, 0.8, 16), matBlack);
            scope.rotation.x = Math.PI / 2;
            scope.position.set(0, 0.4, 0.2);
            rifleGroup.add(scope);

            // Stock
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.8), matBlack);
            stock.position.set(0, -0.1, -1.0);
            rifleGroup.add(stock);

            // Position Rifle in hands
            rifleGroup.position.set(0, 2.1, 0.5);
            group.add(rifleGroup);

            // Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.5, 1.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            hitbox.position.set(0, 1.75, 0);
            hitbox.userData = { isHitbox: true };
            group.add(hitbox);

            return group;
        }

        function createPyroMesh(level = 1) {
            const group = new THREE.Group();

            // Level-based colors
            // Lvl 1: Dark red robe, orange fire
            // Lvl 2: Purple robe, blue fire, shoulder pads
            // Lvl 3: Black robe with gold trim, white-hot fire, floating runes

            const robeColor = level === 3 ? 0x1a1a2e : (level === 2 ? 0x4a1942 : 0x7c2d12);
            const fireColor = level === 3 ? 0xffffff : (level === 2 ? 0x3b82f6 : 0xff4400);
            const fireEmissive = level === 3 ? 0xffffaa : (level === 2 ? 0x60a5fa : 0xff5500);
            const trimColor = level === 3 ? 0xffd700 : (level === 2 ? 0xa855f7 : 0xf97316);

            const matRobe = new THREE.MeshStandardMaterial({ color: robeColor, roughness: 0.9 });
            const matTrim = new THREE.MeshStandardMaterial({ color: trimColor, roughness: 0.6, emissive: trimColor, emissiveIntensity: 0.3 * level });
            const matSkin = new THREE.MeshStandardMaterial({ color: 0xfca5a5, roughness: 0.8 });
            const matStaff = new THREE.MeshStandardMaterial({ color: level === 3 ? 0x8b5a2b : 0x451a03, roughness: 1.0 });
            const matFire = new THREE.MeshStandardMaterial({ color: fireColor, emissive: fireEmissive, emissiveIntensity: 2.0 + level, transparent: true, opacity: 0.9 });

            // Robe Body - taller at higher levels
            const robeHeight = 1.8 + (level * 0.2);
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.6, robeHeight, 8), matRobe);
            body.position.set(0, robeHeight / 2, 0);
            body.castShadow = true;
            group.add(body);

            // Trim at bottom of robe
            const trimRing = new THREE.Mesh(new THREE.TorusGeometry(0.55, 0.08, 8, 16), matTrim);
            trimRing.rotation.x = Math.PI / 2;
            trimRing.position.set(0, 0.1, 0);
            group.add(trimRing);

            // Head (Hooded)
            const hood = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), matRobe);
            hood.position.set(0, robeHeight + 0.3, 0);
            hood.castShadow = true;
            group.add(hood);

            const face = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), matSkin);
            face.position.set(0, robeHeight + 0.3, 0.15);
            group.add(face);

            // Shoulder pads at level 2+
            if (level >= 2) {
                const shoulderL = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), matTrim);
                shoulderL.position.set(-0.5, robeHeight - 0.2, 0);
                group.add(shoulderL);

                const shoulderR = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), matTrim);
                shoulderR.position.set(0.5, robeHeight - 0.2, 0);
                group.add(shoulderR);
            }

            // Staff - more ornate at higher levels
            const staffLength = 2.5 + (level * 0.3);
            const staffHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.07, staffLength), matStaff);
            staffHandle.position.set(0.6, staffLength / 2 + 0.3, 0.5);
            staffHandle.rotation.x = 0.2;
            group.add(staffHandle);

            // Orb on staff - bigger with level
            const orbSize = 0.25 + (level * 0.1);
            const orb = new THREE.Mesh(new THREE.SphereGeometry(orbSize, 16, 16), matFire);
            orb.position.set(0.6, staffLength + 0.5, 0.7);
            group.add(orb);

            // Multiple orbs at level 3
            if (level === 3) {
                const orb2 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), matFire);
                orb2.position.set(0.3, staffLength + 0.3, 0.5);
                group.add(orb2);

                const orb3 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), matFire);
                orb3.position.set(0.9, staffLength + 0.3, 0.5);
                group.add(orb3);
            }

            // Light from staff - brighter with level
            const light = new THREE.PointLight(fireEmissive, 2 + level, 5 + level * 2);
            light.position.set(0.6, staffLength + 0.5, 0.7);
            group.add(light);

            // Floating runes at level 3
            if (level === 3) {
                const runeGeom = new THREE.RingGeometry(0.8, 1.0, 6);
                const runeMat = new THREE.MeshBasicMaterial({ color: 0xffd700, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                const rune = new THREE.Mesh(runeGeom, runeMat);
                rune.rotation.x = Math.PI / 2;
                rune.position.set(0, 0.3, 0);
                group.add(rune);
            }

            // Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.0, 1.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            hitbox.position.set(0, 1.5, 0);
            hitbox.userData = { isHitbox: true };
            group.add(hitbox);

            return group;
        }

        function createTeslaMesh(level = 1) {
            const group = new THREE.Group();

            // Materials
            // Lvl 3 = Gold Plating
            const metalColor = level === 3 ? 0xffd700 : 0x94a3b8;
            const coreColor = level === 3 ? 0xa855f7 : 0x00ffff; // Purple vs Cyan core

            const matMetal = new THREE.MeshStandardMaterial({ color: metalColor, metalness: level === 3 ? 1.0 : 0.9, roughness: 0.2 });
            const matCoil = new THREE.MeshStandardMaterial({ color: 0xb8c0ff, metalness: 0.8, roughness: 0.3 });
            const matEnergy = new THREE.MeshStandardMaterial({ color: coreColor, emissive: coreColor, emissiveIntensity: 2.0 + level });

            // Base platform
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.0, 0.5, 8), matMetal);
            base.position.set(0, 0.25, 0);
            base.castShadow = true;
            group.add(base);

            // Pillar
            const height = 1.5 + ((level - 1) * 0.5); // Taller per level
            const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, height, 8), matMetal);
            pillar.position.set(0, 0.25 + (height / 2), 0);
            group.add(pillar);

            // Coils (Rings)
            const ringCount = 2 + level; // 3, 4, 5 rings
            for (let i = 0; i < ringCount; i++) {
                const ring = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.08, 8, 16), matCoil);
                ring.rotation.x = Math.PI / 2;
                const yPos = 0.8 + (i * (height / ringCount));
                ring.position.set(0, yPos, 0);
                group.add(ring);
            }

            // Top Orb
            const orb = new THREE.Mesh(new THREE.SphereGeometry(0.5 + (level * 0.1), 16, 16), matEnergy);
            orb.position.set(0, 0.25 + height + 0.5, 0);
            group.add(orb);

            // Ambient glow
            const light = new THREE.PointLight(coreColor, 1.5 + level, 4 + level);
            light.position.set(0, 0.25 + height + 0.5, 0);
            group.add(light);

            // Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.5, 1.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            hitbox.position.set(0, 1.75, 0);
            hitbox.userData = { isHitbox: true };
            group.add(hitbox);

            return group;
        }

        // Stats UI Refs
        const uiPanel = document.getElementById('statsPanel');
        uiPanel.style.display = 'none'; // Start hidden
        const uiName = document.getElementById('refName');
        const uiRange = document.getElementById('refRange');
        const uiDamage = document.getElementById('refDamage');
        const uiSpeed = document.getElementById('refSpeed');
        const uiKills = document.getElementById('refKills');
        document.getElementById('btnCloseStats').onclick = () => {
            selectedPlacedTower = null;
            uiPanel.style.display = 'none';
            selectionRing.visible = false;
        };

        const btnUpgrade = document.getElementById('btnUpgrade');
        const refLevel = document.getElementById('refLevel');

        btnUpgrade.addEventListener('click', () => {
            if (!selectedPlacedTower) return;
            const t = selectedPlacedTower;

            // Safety check for level
            if (!t.level) t.level = 1;
            if (!t.maxLevel) t.maxLevel = 3;

            if (t.level >= t.maxLevel) {
                showError("Max Level Reached!");
                return;
            }

            // Upgrade Logic
            t.level++;
            t.damage *= 1.5; // 50% Damage boost
            t.range += 2;    // Slight range boost
            t.cooldown *= 0.9; // 10% Faster

            // Visual Update (Re-mesh)
            const oldPos = t.mesh.position.clone();
            const oldRot = t.mesh.rotation.clone();
            scene.remove(t.mesh);

            let newMesh;
            if (t.type === 'sniper') newMesh = createSniperMesh();
            if (t.type === 'pyro') newMesh = createPyroMesh(t.level);
            if (t.type === 'tesla') newMesh = createTeslaMesh(t.level);
            if (t.type === 'scout') newMesh = createScoutMesh();
            // Fallback
            if (!newMesh) {
                // Basic
                const geom = new THREE.BoxGeometry(1.5, 3 + (t.level * 0.5), 1.5);
                const mat = new THREE.MeshLambertMaterial({ color: 0x0088ff });
                newMesh = new THREE.Mesh(geom, mat);
            }

            newMesh.position.copy(oldPos);
            // newMesh.rotation.copy(oldRot); // Let lookAt logic handle rotation

            newMesh.castShadow = true;
            newMesh.receiveShadow = true;
            scene.add(newMesh);
            t.mesh = newMesh;

            // UI Update
            refLevel.textContent = t.level;
            refDamage.textContent = Math.round(t.damage);
            refRange.textContent = t.range;
            refSpeed.textContent = (300 / t.maxCooldown).toFixed(1);

            if (t.level >= t.maxLevel) {
                btnUpgrade.textContent = "MAX LEVEL";
                btnUpgrade.style.background = "#555";
            }

            showError(`Upgraded to Level ${t.level}!`);
        });

        // Loop to update UI if selection changes (e.g. if we click another tower)
        function updateStatsUI() {
            if (selectedPlacedTower) {
                const t = selectedPlacedTower;
                refLevel.textContent = t.level || 1;
                if (t.level >= t.maxLevel) {
                    btnUpgrade.textContent = "MAX LEVEL";
                    btnUpgrade.style.background = "#555";
                } else {
                    btnUpgrade.textContent = "UPGRADE";
                    btnUpgrade.style.background = "#eab308";
                }
            }
        }
        setInterval(updateStatsUI, 200);

        // let ghostRing = ... (Removed duplicate)

        // Ensure selectionRing is here
        let selectionRing = new THREE.Mesh(new THREE.RingGeometry(1, 1.2, 32), new THREE.MeshBasicMaterial({ color: 0x4ade80, transparent: true, opacity: 0.5, side: THREE.DoubleSide }));
        selectionRing.rotation.x = -Math.PI / 2;
        selectionRing.visible = false;
        scene.add(selectionRing);

        function updateGhost(x, z) {
            if (!selectedTower) {
                ghostRing.visible = false;
                return;
            }
            ghostRing.visible = true;
            ghostRing.position.set(x, 0.2, z);

            // Scale based on tower range
            let range = 8;
            if (selectedTower === 'sniper') range = 60; // Sync with real range
            if (selectedTower === 'scout') range = 10;
            if (selectedTower === 'pyro') range = 6;
            if (selectedTower === 'tesla') range = 15;

            // RingGeometry is static, so scale string
            // Base radius is ~1. So scale to range.
            ghostRing.scale.set(range, range, 1);
        }

        // --- UPDATED INPUT LOGIC ---
        // (Existing raycaster/listeners need to be slightly modified to trigger this)


        function placeTower(x, z, groundY) {
            // ... (keep existing placeTower)
            // Snap to grid
            const snapX = Math.round(x / TILE_SIZE) * TILE_SIZE;
            const snapZ = Math.round(z / TILE_SIZE) * TILE_SIZE;

            // 1. Check existing
            if (towers.some(t => Math.abs(t.mesh.position.x - snapX) < 0.1 && Math.abs(t.mesh.position.z - snapZ) < 0.1)) {
                showError("BLOCKED: Occupied");
                return;
            }

            // 2. Check Path
            if (isPointOnPath(snapX, snapZ)) {
                showError("BLOCKED: Path");
                return;
            }

            // 3. Check High Ground Rule
            // define 'High Ground' as groundY > 0.1
            const isHighGround = groundY > 0.1;

            if (isHighGround && selectedTower !== 'sniper') {
                showError("Only Snipers allow High Ground!");
                return;
            }
            if (!isHighGround && selectedTower === 'sniper') {
                showError("Snipers MUST be on High Ground!");
                return;
            }

            let mesh;
            let range = 8;
            let cooldown = 30; // 0.5s at 60fps

            if (selectedTower === 'scout') {
                mesh = createScoutMesh();
                // Adjust position since group origin is 0,0,0
                mesh.position.set(snapX, groundY, snapZ);
                range = 10;
                cooldown = 15; // Fast fire
            } else if (selectedTower === 'sniper') {
                mesh = createSniperMesh();
                mesh.position.set(snapX, groundY, snapZ);
                range = 60; // Map-wide
                cooldown = 120;
            } else if (selectedTower === 'pyro') {
                mesh = createPyroMesh();
                mesh.position.set(snapX, groundY, snapZ);
                range = 6; // Very short range
                cooldown = 5; // Very fast tick
            } else if (selectedTower === 'tesla') {
                mesh = createTeslaMesh();
                mesh.position.set(snapX, groundY, snapZ);
                range = 15; // Medium range
                cooldown = 45;
            } else {
                // Basic
                const geom = new THREE.BoxGeometry(1.5, 3, 1.5);
                const mat = new THREE.MeshLambertMaterial({ color: 0x0088ff });
                mesh = new THREE.Mesh(geom, mat);
                mesh.position.set(snapX, groundY + 1.5, snapZ);
            }

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const entry = {
                mesh: mesh,
                type: selectedTower,
                range: range,
                damage: selectedTower === 'sniper' ? 50 : (selectedTower === 'scout' ? 10 : (selectedTower === 'pyro' ? 8 : (selectedTower === 'tesla' ? 25 : 20))),
                level: 1,
                maxLevel: 3,
                cooldown: 0,
                maxCooldown: cooldown,
                kills: 0
            };
            towers.push(entry);

            // Link Hitbox for Raycasting
            mesh.traverse(child => {
                if (child.userData.isHitbox) {
                    child.userData.linkedTower = entry;
                }
            });

            // AUTO-UNEQUIP after valid placement
            selectedTower = null;
            ghostRing.visible = false;

            // Reset UI buttons
            const buttons = [btnBasic, btnSniper, btnScout, btnPyro, btnTesla];
            buttons.forEach(b => b.style.borderColor = '#555');
        }

        // Raycaster for clicks
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Prevent context menu
        // Prevent context menu (Right Click) & Cancel Build
        window.addEventListener('contextmenu', e => {
            e.preventDefault();
            if (selectedTower) {
                selectedTower = null;
                ghostRing.visible = false;
                // Reset UI
                const buttons = [btnBasic, btnSniper, btnScout, btnPyro, btnTesla];
                buttons.forEach(b => b.style.borderColor = '#555');
            }
        });

        let isDragging = false;
        let mouseDownPos = new THREE.Vector2();

        window.addEventListener('pointerdown', (event) => {
            if (event.target.tagName === 'BUTTON') return;
            mouseDownPos.set(event.clientX, event.clientY);
            isDragging = false;
        });

        window.addEventListener('pointermove', (event) => {
            const dist = mouseDownPos.distanceTo(new THREE.Vector2(event.clientX, event.clientY));
            if (dist > 5) isDragging = true;

            // Ghost Ring Update
            if (selectedTower) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                // Raycast against ground for ghost
                const intersects = raycaster.intersectObjects([groundPlane, ...terrainObjects]);
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    // Snap
                    const snapX = Math.round(hit.point.x / TILE_SIZE) * TILE_SIZE;
                    const snapZ = Math.round(hit.point.z / TILE_SIZE) * TILE_SIZE;
                    let y = hit.point.y;
                    if (hit.object.userData.isTerrain) y = hit.object.userData.height;

                    updateGhost(snapX, snapZ);
                    ghostRing.position.y = y + 0.2;
                }
            }
        });

        window.addEventListener('pointerup', (event) => {
            if (isDragging) return;
            if (event.button !== 0) return;
            if (event.target.tagName === 'BUTTON') return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // 1. Check if clicked on EXISTING TOWER (Mesh check)
            // ONLY if NOT building (selectedTower is null)
            let hitTower = null;

            if (!selectedTower) {
                // Raycast against scene
                const allIntersects = raycaster.intersectObjects(scene.children, true);

                // Find first tower hit
                for (let i = 0; i < allIntersects.length; i++) {
                    const obj = allIntersects[i].object;

                    // Check if it's a hitbox
                    if (obj.userData.isHitbox) {
                        showDebug("HITBOX CLICKED");

                        // Try explicit link first
                        if (obj.userData.linkedTower) {
                            hitTower = obj.userData.linkedTower;
                            showDebug("TOWER FOUND (LINK)");
                            break;
                        }

                        // Traverse UP to find tower mesh (hitbox -> group -> might be tower)
                        let searchParent = obj.parent;
                        while (searchParent) {
                            const found = towers.find(t => t.mesh === searchParent);
                            if (found) {
                                hitTower = found;
                                showDebug("TOWER FOUND (PARENT SEARCH)");
                                break;
                            }
                            searchParent = searchParent.parent;
                            if (searchParent === scene) break;
                        }

                        if (hitTower) break;
                        showDebug("NO TOWER DATA - CHECK LINKAGE");
                        continue; // Skip non-hitbox fallback for this object
                    }

                    // Fallback: non-hitbox parts of tower
                    let current = obj;
                    while (current) {
                        const towerObj = towers.find(t => t.mesh === current);
                        if (towerObj) {
                            hitTower = towerObj;
                            showDebug("TOWER FOUND (MESH SEARCH)");
                            break;
                        }
                        current = current.parent;
                        if (current === scene) break;
                    }
                    if (hitTower) break;
                }
            }

            if (hitTower) {
                showDebug("OPENING UI...");
                showDebug("Step 1: Set selectedPlacedTower");
                // SELECT TOWER
                selectedPlacedTower = hitTower;
                showDebug("Step 2: Clear selectedTower");
                selectedTower = null; // Exit placement mode checks
                showDebug("Step 3: About to set panel style");

                // Show Stats - FORCED
                uiPanel.style.display = 'block';
                showDebug("Step 4: display=block done");
                uiPanel.style.visibility = 'visible';
                showDebug("Step 5: visibility=visible done");
                uiPanel.style.opacity = '1';
                showDebug("Step 6: opacity=1 done");

                showDebug("PANEL SHOULD BE VISIBLE NOW");

                uiName.textContent = hitTower.type.toUpperCase();
                uiRange.textContent = hitTower.range;
                uiSpeed.textContent = hitTower.maxCooldown * (1000 / 60) + "ms"; // approx
                uiDamage.textContent = hitTower.damage; // Now dynamic
                uiKills.textContent = hitTower.kills || 0;

                // Show Ring
                selectionRing.visible = true;
                selectionRing.position.copy(hitTower.mesh.position);
                selectionRing.position.y = hitTower.mesh.position.y - 1.5 + 0.1; // Base level
                if (hitTower.type === 'scout') selectionRing.position.y = hitTower.mesh.position.y + 0.1; // Scouts are at 0 origin

                selectionRing.scale.set(hitTower.range, hitTower.range, 1);

                return;
            }

            // 2. If no tower hit, try PLACE TOWER (if mode active)
            if (selectedTower) {
                const objectsToCheck = [groundPlane, ...terrainObjects];
                const intersects = raycaster.intersectObjects(objectsToCheck);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const point = hit.point;
                    let groundY = 0;
                    if (hit.object.userData.isTerrain) groundY = hit.object.userData.height;

                    placeTower(point.x, point.z, groundY);
                }
            } else {
                // Clicked empty space: Deselect
                selectedPlacedTower = null;
                // uiPanel.style.display = 'none'; // DEBUG: Commented out to see if this is checking
                selectionRing.visible = false;
            }
        });

        // Projectiles array
        // const projectiles = []; // Removed duplicate declaration

        // Projectiles
        function createProjectile(start, targetPos) {
            const geom = new THREE.SphereGeometry(0.2, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(start);
            scene.add(mesh);

            projectiles.push({
                mesh: mesh,
                target: targetPos, // Store the target position, not the enemy object
                speed: 1.0,
                active: true
            });
        }

        // document.getElementById('spawnBtn').addEventListener('click', spawnEnemy); // Replaced by Wave System

        // --- LOOP ---

        // Initialize ghostRing
        // let ghostRing = createRangeRing(1, 0xffffff); // REMOVED DUPLICATE

        // We need to add it to scene AFTER scene is created, which is done above.
        // Wait, scene is created in the previous block. We should make sure ghostRing is added.
        scene.add(ghostRing);
        ghostRing.visible = false;

        // ... (logic) ...

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Enemy Logic
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (!enemy.active) continue;

                // Move towards next node
                const target = pathNodes[enemy.nodeIndex + 1];
                if (!target) {
                    // Reached end
                    enemy.active = false;
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                    // Lives --? (TODO: Add lives)
                    continue;
                }

                const dir = new THREE.Vector3().subVectors(target, enemy.mesh.position).normalize();
                const dist = enemy.mesh.position.distanceTo(target);

                if (dist < 0.2) {
                    enemy.nodeIndex++;
                    if (enemy.nodeIndex >= pathNodes.length - 1) {
                        enemy.active = false;
                        scene.remove(enemy.mesh);
                        enemies.splice(i, 1);
                    }
                } else {
                    enemy.mesh.position.add(dir.multiplyScalar(enemy.speed));
                }
            }

            // --- WAVE SYSTEM UPDATE ---
            if (waveState === 'SPAWNING') {
                if (spawnTimer > 0) {
                    spawnTimer--;
                } else {
                    spawnEnemy();
                    enemiesToSpawn--;
                    spawnTimer = TIME_BETWEEN_SPAWNS;

                    if (enemiesToSpawn <= 0) {
                        waveState = 'ACTIVE';
                    }
                }
            } else if (waveState === 'ACTIVE') {
                // Check if all enemies dead
                if (enemies.length === 0) {
                    waveState = 'COOLDOWN';
                    waveCooldown = TIME_BETWEEN_WAVES;
                    showError("Wave Cleared! Next wave soon...");
                }
            } else if (waveState === 'COOLDOWN') {
                if (waveCooldown > 0) {
                    waveCooldown--;
                } else {
                    // NEXT WAVE
                    wave++;
                    startWave();
                }
            }

            // Tower Logic (Shooting)
            towers.forEach(t => {
                if (t.cooldown > 0) t.cooldown--;
                else {
                    // Find target
                    let target = null;
                    let minDist = t.range;

                    for (const e of enemies) {
                        const dist = t.mesh.position.distanceTo(e.mesh.position);
                        if (dist < minDist) {
                            minDist = dist;
                            target = e;
                        }
                    }

                    if (target) {
                        t.cooldown = t.maxCooldown;

                        // Look at Target (Y-axis only)
                        t.mesh.lookAt(target.mesh.position.x, t.mesh.position.y, target.mesh.position.z);

                        // PLAY SOUND
                        playSound(t.type);

                        // Create Projectile (Standard)
                        if (t.type !== 'pyro' && t.type !== 'tesla') {
                            createProjectile(t.mesh.position.clone().add(new THREE.Vector3(0, 3, 0)), target.mesh.position);
                        }

                        // VISUAL EFFECTS & SPECIAL LOGIC

                        // Sniper Tracer
                        if (t.type === 'sniper') {
                            const laserGeom = new THREE.BufferGeometry().setFromPoints([
                                t.mesh.position.clone().add(new THREE.Vector3(0, 3, 0)),
                                target.mesh.position
                            ]);
                            const laserMat = new THREE.LineBasicMaterial({ color: 0xffaa00 });
                            const laser = new THREE.Line(laserGeom, laserMat);
                            scene.add(laser);
                            setTimeout(() => scene.remove(laser), 50);
                        }

                        // Pyromancer Flame
                        if (t.type === 'pyro') {
                            // Draw a thicker orange line
                            /* 
                                Ideally particles, but line is easier for single file. 
                            */
                            const laserGeom = new THREE.BufferGeometry().setFromPoints([
                                t.mesh.position.clone().add(new THREE.Vector3(0.6, 2.7, 0.7)), // Staff tip
                                target.mesh.position
                            ]);
                            const laserMat = new THREE.LineBasicMaterial({ color: 0xff4400, linewidth: 3 });
                            const laser = new THREE.Line(laserGeom, laserMat);
                            scene.add(laser);
                            setTimeout(() => scene.remove(laser), 40); // Fast fade for flicker
                        }

                        // Tesla Lightning
                        if (t.type === 'tesla') {
                            const bolts = [];
                            bolts.push(target);

                            // Find targets near the main target (Chain)
                            // Level 1: 2 extra (3 total)
                            // Level 2: 3 extra (4 total)
                            // Level 3: 4 extra (5 total)
                            const chainLimit = 1 + (t.level || 1);
                            const chainRange = 8; // Units to chain lightning
                            let chainCount = 0;
                            for (const e of enemies) {
                                if (chainCount >= chainLimit) break;
                                if (e === target) continue;
                                if (e.mesh.position.distanceTo(target.mesh.position) < chainRange) {
                                    bolts.push(e);
                                    // Deal damage to chained
                                    e.hp -= (t.damage * 0.5); // Half dmg to bounce
                                    if (e.hp <= 0 && e.active) {
                                        e.active = false;
                                        scene.remove(e.mesh);
                                        const idx = enemies.indexOf(e);
                                        if (idx > -1) enemies.splice(idx, 1);
                                        t.kills++;
                                    }
                                    chainCount++;
                                }
                            }

                            // Draw ZigZags
                            const startPos = t.mesh.position.clone().add(new THREE.Vector3(0, 2.5, 0));
                            let prevPos = startPos;

                            bolts.forEach(boltTarget => {
                                const endPos = boltTarget.mesh.position;

                                // Simple Line for now (Zigzag is complex for 1 tool call)
                                const geom = new THREE.BufferGeometry().setFromPoints([prevPos, endPos]);
                                const mat = new THREE.LineBasicMaterial({ color: 0x00ffff });
                                const line = new THREE.Line(geom, mat);
                                scene.add(line);
                                setTimeout(() => scene.remove(line), 100);

                                prevPos = endPos;
                            });
                        }

                        // Damage Logic (Main Target)
                        target.hp -= t.damage;
                        if (target.hp <= 0) {
                            target.active = false;
                            scene.remove(target.mesh);
                            const idx = enemies.indexOf(target);
                            if (idx > -1) enemies.splice(idx, 1);

                            t.kills++;
                            if (selectedPlacedTower === t) {
                                uiKills.textContent = t.kills;
                            }
                        }
                    }
                }
            });

            // Update Counter
            document.getElementById('enemyCountDisplay').textContent = `Enemies: ${enemies.length}`;

            // Update Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (!p.active) continue;

                const dir = new THREE.Vector3().subVectors(p.target, p.mesh.position).normalize();
                p.mesh.position.add(dir.multiplyScalar(2.0)); // Fast speed

                if (p.mesh.position.distanceTo(p.target) < 1.0) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }

            composer.render();
        }

        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>