<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tower Defense</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
        }

        #enemyCountDisplay {
            position: absolute;
            top: 10px;
            right: 50%;
            transform: translateX(50%);
            color: #ff4444;
            font-family: sans-serif;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
        }

        #moneyDisplay {
            position: absolute;
            top: 40px;
            right: 50%;
            transform: translateX(50%);
            color: #4ade80;
            font-family: sans-serif;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        #statsPanel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 41, 59, 0.95);
            padding: 20px;
            border-radius: 8px;
            color: white;
            font-family: sans-serif;
            border: 2px solid #4ade80;
            width: 200px;
            z-index: 99999;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            display: none;
            /* Hidden by default */
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .stat-label {
            color: #94a3b8;
        }

        h2 {
            margin-top: 0;
            font-size: 18px;
            border-bottom: 1px solid #475569;
            padding-bottom: 8px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #ffffff;
            border: none;
            border-radius: 4px;
        }
    </style>
    <!-- Import Three.js module -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">
        <h1>3D Tower Defense</h1>
        <p>Left Click: Place Tower/Select | Right Click: Rotate | Scroll: Zoom</p>
    </div>

    <div id="enemyCountDisplay">Enemies: 0 | Wave: <span id="waveDisplay">1</span></div>
    <div id="moneyDisplay">$500</div>

    <div id="statsPanel">
        <h2 id="refName">Tower</h2>
        <div class="stat-row">
            <span class="stat-label">Range</span>
            <span id="refRange">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Damage</span>
            <span id="refDamage">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Cooldown</span>
            <span id="refSpeed">0ms</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Total Kills</span>
            <span id="refKills">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Level</span>
            <span id="refLevel">1</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">DPS</span>
            <span id="refDPS">0</span>
        </div>
        <button id="btnUpgrade"
            style="width: 100%; margin-top: 10px; background: #eab308; color: black; font-weight: bold; cursor: pointer;">UPGRADE
            ($100)</button>
        <button id="btnCloseStats"
            style="width: 100%; margin-top: 10px; font-size: 12px; background: #ef4444; color: white;">Close</button>
    </div>

    <div id="controls">
        <button id="btnStartWave" style="background: #22c55e; color: white;">Start Game</button>
        <div class="tower-select">
            <button class="tower-btn" onclick="selectTower('basic')" data-cost="100">Basic<br><span
                    style="color:#4ade80;font-size:0.8em">$100</span></button>
            <button class="tower-btn" onclick="selectTower('sniper')" data-cost="250">Sniper<br><span
                    style="color:#4ade80;font-size:0.8em">$250</span></button>
            <button class="tower-btn" onclick="selectTower('scout')" data-cost="150">Scout<br><span
                    style="color:#4ade80;font-size:0.8em">$150</span></button>
            <button class="tower-btn" onclick="selectTower('pyro')" data-cost="200"
                style="border-bottom: 3px solid #f97316">Pyro<br><span
                    style="color:#4ade80;font-size:0.8em">$200</span></button>
            <button class="tower-btn" onclick="selectTower('tesla')" data-cost="300"
                style="border-bottom: 3px solid #3b82f6">Tesla<br><span
                    style="color:#4ade80;font-size:0.8em">$300</span></button>

            <button class="tower-btn" onclick="selectTower('glacier')" data-cost="350"
                style="border-bottom: 3px solid #06b6d4">Glacier<br><span
                    style="color:#4ade80;font-size:0.8em">$350</span></button>
            <button class="tower-btn" onclick="selectTower('rocket')" data-cost="600"
                style="border-bottom: 3px solid #22c55e">Rocket<br><span
                    style="color:#4ade80;font-size:0.8em">$600</span></button>
            <button class="tower-btn" onclick="selectTower('amp')" data-cost="800"
                style="border-bottom: 3px solid #a855f7">Amp<br><span
                    style="color:#4ade80;font-size:0.8em">$800</span></button>
            <button class="tower-btn" onclick="selectTower('railgun')" data-cost="1000"
                style="border-bottom: 3px solid #ef4444">Railgun<br><span
                    style="color:#4ade80;font-size:0.8em">$1k</span></button>
            <button class="tower-btn" onclick="selectTower('miner')" data-cost="400"
                style="border-bottom: 3px solid #eab308">Miner<br><span
                    style="color:#4ade80;font-size:0.8em">$400</span></button>
        </div>
        <div style="width: 20px;"></div>
        <button id="btnSpeed" style="border: 2px solid #a855f7; color: #a855f7;">Speed: 1x</button>
        <button id="btnMusic" style="border: 2px solid #888;">ðŸŽµ Music</button>
    </div>

    <!-- Background Music (Hidden) -->
    <div id="musicContainer" style="display:none;"></div>
    <script>
        // Simple YouTube Player Embed Logic
        // We inject the iframe when button is clicked to bypass some autoplay restrictions cleanly
        const btnMusic = document.getElementById('btnMusic');
        let musicPlaying = false;

        btnMusic.addEventListener('click', () => {
            const container = document.getElementById('musicContainer');
            if (!musicPlaying) {
                container.innerHTML = '<iframe width="1" height="1" src="https://www.youtube.com/embed/vq2AfGYwbE4?autoplay=1&loop=1&playlist=vq2AfGYwbE4" frameborder="0" allow="autoplay"></iframe>';
                musicPlaying = true;
                btnMusic.style.borderColor = '#4ade80'; // Green
                btnMusic.textContent = "ðŸ”Š Music On";
            } else {
                container.innerHTML = '';
                musicPlaying = false;
                btnMusic.style.borderColor = '#888';
                btnMusic.textContent = "ðŸŽµ Music Off";
            }
        });

        // --- GAME SPEED CONTROL ---
        let gameSpeed = 1;
        const speedOptions = [1, 2, 5, 10, 20, 50, 100, 200];
        let speedIndex = 0;
        const btnSpeed = document.getElementById('btnSpeed');

        btnSpeed.addEventListener('click', () => {
            speedIndex = (speedIndex + 1) % speedOptions.length;
            gameSpeed = speedOptions[speedIndex];
            btnSpeed.textContent = `Speed: ${gameSpeed}x`;
            if (gameSpeed > 1) {
                btnSpeed.style.background = '#a855f7';
                btnSpeed.style.color = 'white';
            } else {
                btnSpeed.style.background = '';
                btnSpeed.style.color = '#a855f7';
            }
        });

        // --- SOUND FX ENGINE (Web Audio API) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        // Resume audio context on first user interaction
        window.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }, { once: true });

        function playSound(type) {
            if (audioCtx.state === 'suspended') return;

            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'sniper') {
                // BIG BANG
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);

                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

                osc.start(now);
                osc.stop(now + 0.4);

            } else if (type === 'pyro') {
                // HISS / WHITE NOISE (Simulated with erratic saw)
                // Real noise requires buffer, let's try erratic saw for "fire"
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.1);

                // Quick envelope
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.2);

                osc.start(now);
                osc.stop(now + 0.2);

            } else if (type === 'tesla') {
                // ZAP (High pitch slide)
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.1);

                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

                osc.start(now);
                osc.stop(now + 0.1);

            } else {
                // BASIC PEW
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);

                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

                osc.start(now);
                osc.stop(now + 0.1);
            }
        }
    </script>

    <!-- INLINE SCRIPT TO AVOID CORS ISSUES ON LOCAL FILESYSTEM -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Helper for Range Ring
        function createRangeRing(radius, color) {
            const geometry = new THREE.RingGeometry(radius - 0.2, radius, 64);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.y = 0.1; // Just above ground/road
            return mesh;
        }

        let ghostRing = createRangeRing(1, 0xffffff);

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505); // Darker background for bloom
        scene.fog = new THREE.Fog(0x050505, 20, 60);

        // Isometric view
        const aspect = window.innerWidth / window.innerHeight;
        const d = 60; // Zoom out for larger map
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20);
        camera.lookAt(scene.position);

        // --- REALISTIC RENDERER SETUP ---
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows

        // Tone Mapping & Color Space
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        document.body.appendChild(renderer.domElement);

        // --- POST-PROCESSING ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Bloom: Threshold (0-1), Strength, Radius
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.6; // Only VERY bright things glow
        bloomPass.strength = 0.8;  // Intensity
        bloomPass.radius = 0.5;    // Spread
        composer.addPass(bloomPass);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.maxPolarAngle = Math.PI / 2; // Prevent going under the map

        // Remap controls to standard RTS style
        controls.mouseButtons = {
            LEFT: THREE.MOUSE.PAN,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.ROTATE
        };


        // --- ADVANCED LIGHTING ---
        // 1. Hemisphere Light (Sky/Ground Ambient)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        // 2. Main Sun Directional Light
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); // Higher intensity for tone mapping
        dirLight.position.set(20, 40, 10);
        dirLight.castShadow = true;
        // Shadow properties
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -40;
        dirLight.shadow.camera.right = 40;
        dirLight.shadow.camera.top = 40;
        dirLight.shadow.camera.bottom = -40;
        dirLight.shadow.bias = -0.0005; // Fix shadow acne
        scene.add(dirLight);

        // --- GAME OBJECTS ---
        const TILE_SIZE = 2;
        const MAP_SIZE = 60;
        // Expanded path (5x larger and longer)
        const pathNodes = [
            new THREE.Vector3(-40, 0, -40),
            new THREE.Vector3(-40, 0, 20),
            new THREE.Vector3(-10, 0, 20),
            new THREE.Vector3(-10, 0, -20),
            new THREE.Vector3(20, 0, -20),
            new THREE.Vector3(20, 0, 20),
            new THREE.Vector3(50, 0, 20),
            new THREE.Vector3(50, 0, -50)
        ];

        // Large Ground Plane
        const planeGeom = new THREE.PlaneGeometry(500, 500);
        const planeMat = new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.8 });
        const groundPlane = new THREE.Mesh(planeGeom, planeMat);
        groundPlane.rotation.x = -Math.PI / 2;
        groundPlane.receiveShadow = true;
        scene.add(groundPlane);

        // Function to create road segments
        function createRoad() {
            const roadMat = new THREE.MeshStandardMaterial({
                color: 0x334155,
                roughness: 0.9,
                polygonOffset: true,
                polygonOffsetFactor: -1 // Draw on top of ground
            });

            for (let i = 0; i < pathNodes.length - 1; i++) {
                const start = pathNodes[i];
                const end = pathNodes[i + 1];

                const vec = new THREE.Vector3().subVectors(end, start);
                const length = vec.length();
                const angle = Math.atan2(vec.z, vec.x);

                // Segment mesh (+ extra length to cover corners)
                const geometry = new THREE.PlaneGeometry(length + (TILE_SIZE / 2), TILE_SIZE * 0.8);
                const mesh = new THREE.Mesh(geometry, roadMat);

                // Position at midpoint
                const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                mesh.position.copy(mid);
                mesh.position.y = 0.02; // Slightly above ground
                mesh.rotation.x = -Math.PI / 2;
                mesh.rotation.z = -angle;

                mesh.receiveShadow = true;
                scene.add(mesh);

                // Add rounded corners at nodes? maybe later. Simple rects for now.
            }
        }
        createRoad();

        // Green spawn point marker
        const spawnMarkerGeom = new THREE.CircleGeometry(3, 16);
        const spawnMarkerMat = new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.7 });
        const spawnMarker = new THREE.Mesh(spawnMarkerGeom, spawnMarkerMat);
        spawnMarker.rotation.x = -Math.PI / 2;
        spawnMarker.position.set(pathNodes[0].x, 0.03, pathNodes[0].z);
        scene.add(spawnMarker);

        // Green glow light at spawn
        const spawnLight = new THREE.PointLight(0x22c55e, 1, 10);
        spawnLight.position.set(pathNodes[0].x, 1, pathNodes[0].z);
        scene.add(spawnLight);


        const towers = [];
        const enemies = [];
        const projectiles = []; // Removed duplicate declaration

        // Tower selection state
        let selectedPlacedTower = null; // Existing tower that is selected for viewing stats
        let selectedTower = null; // New tower type selected for placement

        function selectTower(type) {
            if (selectedTower === type) {
                selectedTower = null;
            } else {
                selectedTower = type;
                // Deselect placed tower
                selectedPlacedTower = null;
                document.getElementById('statsPanel').style.display = 'none';
                selectionRing.visible = false;
            }

            // Visual update
            document.querySelectorAll('.tower-btn').forEach(btn => {
                btn.style.borderColor = 'transparent';
                // Check if this button corresponds to the selected type
                if (selectedTower && btn.getAttribute('onclick').includes(`'${selectedTower}'`)) {
                    btn.style.borderColor = '#ffffff';
                }
            });
        }
        window.selectTower = selectTower;


        // --- MONEY SYSTEM ---
        let money = 500; // Starting money
        const TOWER_COSTS = {
            basic: 100,
            sniper: 250,
            scout: 150,
            pyro: 200,
            tesla: 300,
            glacier: 350,
            rocket: 600,
            amp: 800,
            railgun: 1000,
            miner: 400
        };

        const TOWER_TYPES = {
            basic: { cost: 100, range: 4.0, damage: 10, cooldown: 60, color: 0x3b82f6, name: 'Basic Tower', type: 'basic' },
            sniper: { cost: 250, range: 18.0, damage: 50, cooldown: 120, color: 0x555555, name: 'Sniper Tower', type: 'sniper' },
            scout: { cost: 150, range: 3.0, damage: 5, cooldown: 30, color: 0x888888, name: 'Scout Tower', type: 'scout' },
            pyro: { cost: 200, range: 2.5, damage: 1, cooldown: 5, color: 0xff6600, name: 'Pyromancer', type: 'pyro' },
            tesla: { cost: 300, range: 3.5, damage: 15, cooldown: 45, color: 0x00ccff, name: 'Tesla Coil', type: 'tesla' },
            // New Towers
            glacier: { cost: 350, range: 3.5, damage: 5, cooldown: 40, color: 0x00ffff, name: 'Glacier', type: 'glacier', isSlow: true },
            rocket: { cost: 600, range: 6.0, damage: 40, cooldown: 120, color: 0x228b22, name: 'Rocket', type: 'rocket', isSplash: true, splashRadius: 2.5 },
            amp: { cost: 800, range: 4.0, damage: 0, cooldown: 0, color: 0x9333ea, name: 'Amplifier', type: 'amp', isSupport: true },
            railgun: { cost: 1000, range: 8.0, damage: 60, cooldown: 90, color: 0xff0000, name: 'Railgun', type: 'railgun', isPiercing: true },
            miner: { cost: 400, range: 0, damage: 0, cooldown: 300, color: 0xffaa00, name: 'Nanominer', type: 'miner', isEconomy: true, generation: 25 }
        };

        const UPGRADE_COST_BASE = 100; // Cost increases per level

        function getUpgradeCost(tower) {
            return UPGRADE_COST_BASE * tower.level;
        }

        function addMoney(amount) {
            money += amount;
            updateMoneyDisplay();
        }

        function spendMoney(amount) {
            if (money >= amount) {
                money -= amount;
                updateMoneyDisplay();
                return true;
            }
            return false;
        }

        function updateMoneyDisplay() {
            const display = document.getElementById('moneyDisplay');
            if (display) display.textContent = `$${money}`;
        }

        // --- WAVE SYSTEM VARIABLES ---
        let wave = 1;
        let waveState = 'IDLE'; // IDLE, SPAWNING, ACTIVE, COOLDOWN
        let enemiesToSpawn = 0;
        let spawnTimer = 0;
        let waveCooldown = 0;
        const TIME_BETWEEN_SPAWNS = 40; // ~0.7s
        const TIME_BETWEEN_WAVES = 300; // ~5s
        let isGameOver = false;

        function gameOver() {
            if (isGameOver) return;
            isGameOver = true;
            waveState = 'IDLE';

            // Show game over overlay
            const overlay = document.createElement('div');
            overlay.id = 'gameOverOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
            overlay.innerHTML = `
                <h1 style="color: #ff4444; font-size: 64px; font-family: sans-serif; margin: 0;">GAME OVER</h1>
                <p style="color: white; font-size: 24px; font-family: sans-serif;">An enemy reached your base!</p>
                <p style="color: #888; font-size: 18px; font-family: sans-serif;">Wave Reached: ${wave}</p>
                <button id="btnRestart" style="margin-top: 30px; padding: 15px 40px; font-size: 20px; background: #22c55e; color: white; border: none; cursor: pointer; border-radius: 8px;">RESTART</button>
            `;
            document.body.appendChild(overlay);

            document.getElementById('btnRestart').addEventListener('click', () => {
                location.reload();
            });
        }

        // --- ENEMY TYPES ---
        const ENEMY_TYPES = {
            normal: { name: 'Normal', hpMult: 1.0, speedMult: 1.0, size: 0.6, color: 0xff4444 },
            speedster: { name: 'Speedster', hpMult: 0.6, speedMult: 2.0, size: 0.4, color: 0x00ff00 },
            giant: { name: 'Giant', hpMult: 3.0, speedMult: 0.5, size: 1.2, color: 0x8b4513 },
            boss: { name: 'BOSS', hpMult: 15.0, speedMult: 0.3, size: 2.0, color: 0xff00ff },
            // Molten variants (Wave 25+)
            molten_normal: { name: 'Molten', hpMult: 2.0, speedMult: 1.2, size: 0.7, color: 0xff6600, isMolten: true },
            molten_speedster: { name: 'Molten Speedster', hpMult: 1.2, speedMult: 2.5, size: 0.5, color: 0xff9900, isMolten: true },
            molten_giant: { name: 'Molten Giant', hpMult: 5.0, speedMult: 0.6, size: 1.5, color: 0xcc3300, isMolten: true },
            molten_boss: { name: 'INFERNO BOSS', hpMult: 25.0, speedMult: 0.4, size: 2.5, color: 0xff0000, isMolten: true },
            // Frozen variants (Wave 50+)
            frozen_normal: { name: 'Frozen', hpMult: 3.0, speedMult: 1.0, size: 0.8, color: 0x88ddff, isFrozen: true },
            frozen_speedster: { name: 'Frozen Speedster', hpMult: 2.0, speedMult: 2.2, size: 0.6, color: 0x66ccff, isFrozen: true },
            frozen_giant: { name: 'Frozen Giant', hpMult: 8.0, speedMult: 0.5, size: 1.8, color: 0x4488cc, isFrozen: true },
            frozen_boss: { name: 'BLIZZARD LORD', hpMult: 40.0, speedMult: 0.35, size: 3.0, color: 0x00aaff, isFrozen: true },
            // Void variants (Wave 75+)
            void_normal: { name: 'Void', hpMult: 4.0, speedMult: 1.1, size: 0.9, color: 0x6600cc, isVoid: true },
            void_speedster: { name: 'Void Speedster', hpMult: 3.0, speedMult: 2.5, size: 0.7, color: 0x9933ff, isVoid: true },
            void_giant: { name: 'Void Giant', hpMult: 12.0, speedMult: 0.55, size: 2.0, color: 0x4400aa, isVoid: true },
            void_boss: { name: 'VOID EMPEROR', hpMult: 50.0, speedMult: 0.3, size: 3.5, color: 0x220033, isVoid: true },
            // Heavenly variants (Wave 100+)
            heavenly_normal: { name: 'Angel', hpMult: 6.0, speedMult: 1.2, size: 0.9, color: 0xffffaa, isHeavenly: true },
            heavenly_speedster: { name: 'Seraph', hpMult: 4.0, speedMult: 3.0, size: 0.7, color: 0xffffff, isHeavenly: true },
            heavenly_giant: { name: 'Guardian', hpMult: 12.0, speedMult: 0.5, size: 2.2, color: 0xffcc00, isHeavenly: true },
            heavenly_boss: { name: 'DIVINE TITAN', hpMult: 80.0, speedMult: 0.25, size: 4.0, color: 0xffaa00, isHeavenly: true },
            // Cyber variants (Wave 200+)
            cyber_normal: { name: 'Cyber Drone', hpMult: 10.0, speedMult: 1.3, size: 0.8, color: 0x00ff00, isCyber: true },
            cyber_speedster: { name: 'Cyber Runner', hpMult: 6.0, speedMult: 3.5, size: 0.6, color: 0x00ffff, isCyber: true },
            cyber_giant: { name: 'Cyber Tank', hpMult: 20.0, speedMult: 0.4, size: 2.5, color: 0xbf00ff, isCyber: true },
            cyber_gunner: { name: 'Cyber Gunner', hpMult: 8.0, speedMult: 0.8, size: 1.0, color: 0xff00ff, isCyber: true, isGunner: true },
            cyber_boss: { name: 'CYBER OVERLORD', hpMult: 150.0, speedMult: 0.2, size: 5.0, color: 0xff0000, isCyber: true }
        };

        let isLavaRealm = false; // Tracks if we've entered lava realm
        let isIceRealm = false; // Tracks if we've entered ice realm
        let isVoidRealm = false; // Tracks if we've entered void realm
        let isHeavenlyRealm = false; // Tracks if we've entered heavenly realm
        let isCyberRealm = false; // Tracks if we've entered cyber realm

        // Store biome objects for cleanup
        let biomeObjects = [];

        // --- MUTATIONS ---
        const MUTATIONS = {
            none: { name: '', effect: null },
            loaded: { name: 'Loaded', damageReduction: 0.5, color: 0x808080 }, // 50% damage reduction
            nimble: { name: 'Nimble', speedMult: 2.0, color: 0x00ffff },
            regen: { name: 'Regen', regenRate: 5, color: 0x00ff00 }, // HP per second
            flying: { name: 'Flying', isFlying: true, color: 0xffff00, height: 3.0 }
        };

        function spawnEnemy(typeOverride, mutationOverride) {
            // Determine enemy type
            let type = typeOverride || 'normal';

            // Random type selection if not overridden
            if (!typeOverride) {
                const roll = Math.random();
                if (roll < 0.15) type = 'speedster';
                else if (roll < 0.25) type = 'giant';

                // Use realm variants based on wave
                if (wave >= 200) {
                    type = 'cyber_' + type;
                } else if (wave >= 100) {
                    type = 'heavenly_' + type;
                } else if (wave >= 75) {
                    type = 'void_' + type;
                } else if (wave >= 50) {
                    type = 'frozen_' + type;
                } else if (wave >= 25) {
                    type = 'molten_' + type;
                }
            }

            const typeData = ENEMY_TYPES[type];

            // Determine mutation (chance increases with wave)
            let mutation = mutationOverride || 'none';
            if (!mutationOverride && wave >= 3) {
                const mutationChance = Math.min(0.4, 0.05 * wave);
                if (Math.random() < mutationChance) {
                    const mutations = ['loaded', 'nimble', 'regen'];
                    if (wave >= 5) mutations.push('flying');
                    mutation = mutations[Math.floor(Math.random() * mutations.length)];
                }
            }
            const mutData = MUTATIONS[mutation];

            // Create mesh
            const geom = new THREE.SphereGeometry(typeData.size, 16, 16);

            // Color based on type, tinted by mutation
            let baseColor = new THREE.Color(typeData.color);
            if (mutation !== 'none') {
                baseColor.lerp(new THREE.Color(mutData.color), 0.4);
            }

            const mat = new THREE.MeshLambertMaterial({ color: baseColor });
            const mesh = new THREE.Mesh(geom, mat);

            const start = pathNodes[0];
            mesh.position.copy(start);
            mesh.position.y = typeData.size + (mutData.isFlying ? mutData.height : 0);

            // Add visual indicators for mutations
            if (mutation === 'flying') {
                // Add wings
                const wingMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                const wingL = new THREE.Mesh(new THREE.PlaneGeometry(typeData.size * 1.5, typeData.size * 0.8), wingMat);
                wingL.position.set(-typeData.size * 0.8, 0, 0);
                wingL.rotation.y = Math.PI / 4;
                mesh.add(wingL);
                const wingR = new THREE.Mesh(new THREE.PlaneGeometry(typeData.size * 1.5, typeData.size * 0.8), wingMat);
                wingR.position.set(typeData.size * 0.8, 0, 0);
                wingR.rotation.y = -Math.PI / 4;
                mesh.add(wingR);
            }

            if (mutation === 'loaded') {
                // Add armor plates
                const armorMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                const armor = new THREE.Mesh(new THREE.BoxGeometry(typeData.size * 1.2, typeData.size * 0.3, typeData.size * 1.2), armorMat);
                armor.position.set(0, typeData.size * 0.5, 0);
                mesh.add(armor);
            }

            if (mutation === 'regen') {
                // Add green glow
                const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3 });
                const glow = new THREE.Mesh(new THREE.SphereGeometry(typeData.size * 1.3, 8, 8), glowMat);
                mesh.add(glow);
            }

            // Molten enemy effects
            if (typeData.isMolten) {
                // Fire glow
                const fireMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.4 });
                const fireGlow = new THREE.Mesh(new THREE.SphereGeometry(typeData.size * 1.2, 8, 8), fireMat);
                mesh.add(fireGlow);

                // Point light
                const fireLight = new THREE.PointLight(0xff4400, 1, typeData.size * 4);
                mesh.add(fireLight);
            }

            // Frozen enemy effects
            if (typeData.isFrozen) {
                // Ice glow
                const iceMat = new THREE.MeshBasicMaterial({ color: 0x88ddff, transparent: true, opacity: 0.3 });
                const iceGlow = new THREE.Mesh(new THREE.SphereGeometry(typeData.size * 1.2, 8, 8), iceMat);
                mesh.add(iceGlow);

                // Ice crystals
                const crystalMat = new THREE.MeshBasicMaterial({ color: 0xaaeeff, transparent: true, opacity: 0.7 });
                for (let i = 0; i < 4; i++) {
                    const crystal = new THREE.Mesh(new THREE.ConeGeometry(typeData.size * 0.15, typeData.size * 0.4, 4), crystalMat);
                    crystal.position.set(
                        Math.cos(i * Math.PI / 2) * typeData.size * 0.6,
                        typeData.size * 0.3,
                        Math.sin(i * Math.PI / 2) * typeData.size * 0.6
                    );
                    mesh.add(crystal);
                }

                // Cold light
                const iceLight = new THREE.PointLight(0x88ddff, 0.8, typeData.size * 4);
                mesh.add(iceLight);
            }

            // Void enemy effects
            if (typeData.isVoid) {
                // Void glow (dark purple)
                const voidMat = new THREE.MeshBasicMaterial({ color: 0x6600cc, transparent: true, opacity: 0.5 });
                const voidGlow = new THREE.Mesh(new THREE.SphereGeometry(typeData.size * 1.3, 8, 8), voidMat);
                mesh.add(voidGlow);

                // Floating dark particles (rings)
                for (let i = 0; i < 3; i++) {
                    const ringMat = new THREE.MeshBasicMaterial({ color: 0x9933ff, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                    const ring = new THREE.Mesh(new THREE.RingGeometry(typeData.size * (0.8 + i * 0.3), typeData.size * (0.9 + i * 0.3), 8), ringMat);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = i * 0.3 - 0.2;
                    mesh.add(ring);
                }

                // Void light (dark purple glow)
                const voidLight = new THREE.PointLight(0x6600cc, 1, typeData.size * 5);
                mesh.add(voidLight);
            }

            // Heavenly enemy effects
            if (typeData.isHeavenly) {
                // Golden glow
                const goldenMat = new THREE.MeshBasicMaterial({ color: 0xffdd88, transparent: true, opacity: 0.4 });
                const goldenGlow = new THREE.Mesh(new THREE.SphereGeometry(typeData.size * 1.4, 8, 8), goldenMat);
                mesh.add(goldenGlow);

                // Halo
                const haloMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                const halo = new THREE.Mesh(new THREE.RingGeometry(typeData.size * 0.6, typeData.size * 0.8, 16), haloMat);
                halo.rotation.x = Math.PI / 2;
                halo.position.y = typeData.size + 0.3;
                mesh.add(halo);

                // Angel wings
                const wingMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
                const wingL = new THREE.Mesh(new THREE.PlaneGeometry(typeData.size * 1.2, typeData.size * 0.8), wingMat);
                wingL.position.set(-typeData.size * 0.8, typeData.size * 0.2, -0.2);
                wingL.rotation.y = Math.PI / 3;
                mesh.add(wingL);
                const wingR = new THREE.Mesh(new THREE.PlaneGeometry(typeData.size * 1.2, typeData.size * 0.8), wingMat);
                wingR.position.set(typeData.size * 0.8, typeData.size * 0.2, -0.2);
                wingR.rotation.y = -Math.PI / 3;
                mesh.add(wingR);

                // Divine light
                const divineLight = new THREE.PointLight(0xffffaa, 1.5, typeData.size * 6);
                mesh.add(divineLight);
            }

            // Cyber enemy effects
            if (typeData.isCyber) {
                // Glowing lines/circuits
                const circuitMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
                const circuit1 = new THREE.Mesh(new THREE.CylinderGeometry(typeData.size * 0.8, typeData.size * 0.8, 0.1, 16), circuitMat);
                circuit1.position.y = typeData.size * 0.5;
                mesh.add(circuit1);
                const circuit2 = new THREE.Mesh(new THREE.CylinderGeometry(typeData.size * 0.8, typeData.size * 0.8, 0.1, 16), circuitMat);
                circuit2.rotation.x = Math.PI / 2;
                circuit2.position.z = typeData.size * 0.5;
                mesh.add(circuit2);

                // Cyber glow
                const cyberLight = new THREE.PointLight(0x00ffff, 1.2, typeData.size * 5);
                mesh.add(cyberLight);

                // If it's a gunner, add a small gun
                if (typeData.isGunner) {
                    const gunMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });
                    const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.5), gunMat);
                    gunBody.position.set(typeData.size * 0.5, 0, typeData.size * 0.5);
                    mesh.add(gunBody);
                    const gunBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.8), gunMat);
                    gunBarrel.position.set(typeData.size * 0.5, 0, typeData.size * 0.9);
                    mesh.add(gunBarrel);
                }
            }

            scene.add(mesh);

            // Calculate HP (balanced for early waves)
            const baseHp = 50 + (wave * 15); // Wave 1 = 65 HP, scales slower
            const hp = Math.floor(baseHp * typeData.hpMult);

            // Calculate speed
            let speed = (0.06 + (wave * 0.003)) * typeData.speedMult;
            if (mutData.speedMult) speed *= mutData.speedMult;

            enemies.push({
                mesh: mesh,
                nodeIndex: 0,
                hp: hp,
                maxHp: hp,
                speed: speed,
                active: true,
                type: type,
                typeName: typeData.name,
                mutation: mutation,
                mutationName: mutData.name || '',
                damageReduction: mutData.damageReduction || 0,
                regenRate: mutData.regenRate || 0,
                isFlying: mutData.isFlying || false,
                isGunner: typeData.isGunner || false, // Add isGunner property
                baseY: typeData.size + (mutData.isFlying ? mutData.height : 0)
            });
        }

        function spawnBoss() {
            // Use realm boss
            let type = 'boss';
            let name = 'MEGA BOSS';

            if (wave >= 200) {
                type = 'cyber_boss';
                name = 'CYBER OVERLORD';
            } else if (wave >= 100) {
                type = 'heavenly_boss';
                name = 'DIVINE TITAN';
            } else if (wave >= 75) {
                type = 'void_boss';
                name = 'VOID EMPEROR';
            } else if (wave >= 50) {
                type = 'frozen_boss';
                name = 'â„ï¸ BLIZZARD LORD';
            } else if (wave >= 25) {
                type = 'molten_boss';
                name = 'ðŸ”¥ INFERNO BOSS';
            }

            spawnEnemy(type, 'none');
            showError(`âš ï¸ ${name} INCOMING! âš ï¸`);
        }

        // Transform terrain to lava realm
        function transformToLavaRealm() {
            if (isLavaRealm) return;
            isLavaRealm = true;

            showError('ðŸŒ‹ THE REALM TRANSFORMS... ðŸŒ‹');

            // Change ground to lava colors
            groundPlane.material.color.setHex(0x1a0a00);
            groundPlane.material.emissive = new THREE.Color(0x330000);
            groundPlane.material.emissiveIntensity = 0.3;

            // Change scene background and fog
            scene.background = new THREE.Color(0x1a0500);
            scene.fog = new THREE.Fog(0x1a0500, 20, 80);

            // Change terrain objects to molten rock
            terrainObjects.forEach(obj => {
                obj.material = new THREE.MeshStandardMaterial({
                    color: 0x2a1a0a,
                    emissive: 0x441100,
                    emissiveIntensity: 0.5,
                    roughness: 0.8
                });
            });

            // Add lava pools (simple glowing circles on ground)
            for (let i = 0; i < 15; i++) {
                const poolGeom = new THREE.CircleGeometry(2 + Math.random() * 3, 16);
                const poolMat = new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    transparent: true,
                    opacity: 0.7
                });
                const pool = new THREE.Mesh(poolGeom, poolMat);
                pool.rotation.x = -Math.PI / 2;
                pool.position.set(
                    (Math.random() - 0.5) * 80,
                    0.05,
                    (Math.random() - 0.5) * 80
                );
                scene.add(pool);
                biomeObjects.push(pool);

                // Add glow light
                const lavaLight = new THREE.PointLight(0xff2200, 0.5, 8);
                lavaLight.position.copy(pool.position);
                lavaLight.position.y = 0.5;
                scene.add(lavaLight);
                biomeObjects.push(lavaLight);
            }
        }

        // Cleanup previous biome objects
        function cleanupBiomeObjects() {
            biomeObjects.forEach(obj => {
                scene.remove(obj);
            });
            biomeObjects = [];
        }

        // Transform terrain to ice realm
        function transformToIceRealm() {
            if (isIceRealm) return;
            isIceRealm = true;

            // Cleanup previous biome objects
            cleanupBiomeObjects();

            showError('â„ï¸ THE REALM FREEZES... â„ï¸');

            // Change ground to frozen colors
            groundPlane.material.color.setHex(0x1a2a3a);
            groundPlane.material.emissive = new THREE.Color(0x112233);
            groundPlane.material.emissiveIntensity = 0.2;

            // Change scene background and fog
            scene.background = new THREE.Color(0x0a1520);
            scene.fog = new THREE.Fog(0x0a1520, 15, 70);

            // Change terrain objects to frozen rock
            terrainObjects.forEach(obj => {
                obj.material = new THREE.MeshStandardMaterial({
                    color: 0x4488aa,
                    emissive: 0x224466,
                    emissiveIntensity: 0.3,
                    roughness: 0.3,
                    metalness: 0.5
                });
            });

            // Add ice patches (crystalline surfaces)
            for (let i = 0; i < 20; i++) {
                const patchGeom = new THREE.CircleGeometry(1.5 + Math.random() * 2.5, 6);
                const patchMat = new THREE.MeshBasicMaterial({
                    color: 0x88ddff,
                    transparent: true,
                    opacity: 0.5
                });
                const patch = new THREE.Mesh(patchGeom, patchMat);
                patch.rotation.x = -Math.PI / 2;
                patch.position.set(
                    (Math.random() - 0.5) * 80,
                    0.06,
                    (Math.random() - 0.5) * 80
                );
                scene.add(patch);

                // Add ice crystals on some patches
                if (Math.random() > 0.5) {
                    const crystalMat = new THREE.MeshBasicMaterial({ color: 0xaaeeff, transparent: true, opacity: 0.8 });
                    for (let j = 0; j < 3; j++) {
                        const crystal = new THREE.Mesh(new THREE.ConeGeometry(0.3, 1.5 + Math.random(), 4), crystalMat);
                        crystal.position.copy(patch.position);
                        crystal.position.x += (Math.random() - 0.5) * 2;
                        crystal.position.z += (Math.random() - 0.5) * 2;
                        crystal.position.y = 0.75;
                        scene.add(crystal);
                        biomeObjects.push(crystal);
                    }
                }

                // Add cold light
                const iceLight = new THREE.PointLight(0x88ddff, 0.3, 6);
                iceLight.position.copy(patch.position);
                iceLight.position.y = 0.5;
                scene.add(iceLight);
                biomeObjects.push(patch);
                biomeObjects.push(iceLight);
            }
        }

        // Transform terrain to void realm
        function transformToVoidRealm() {
            if (isVoidRealm) return;
            isVoidRealm = true;

            // Cleanup previous biome objects
            cleanupBiomeObjects();

            showError('ðŸ•³ï¸ THE VOID CONSUMES ALL... ðŸ•³ï¸');

            // Change ground to void colors (dark purple/black)
            groundPlane.material.color.setHex(0x0a0010);
            groundPlane.material.emissive = new THREE.Color(0x220044);
            groundPlane.material.emissiveIntensity = 0.4;

            // Change scene background and fog (very dark purple)
            scene.background = new THREE.Color(0x050008);
            scene.fog = new THREE.Fog(0x050008, 10, 60);

            // Change terrain objects to void corruption
            terrainObjects.forEach(obj => {
                obj.material = new THREE.MeshStandardMaterial({
                    color: 0x2a0044,
                    emissive: 0x440088,
                    emissiveIntensity: 0.6,
                    roughness: 0.5,
                    metalness: 0.7
                });
            });

            // Add void rifts (glowing purple cracks)
            for (let i = 0; i < 12; i++) {
                const riftGeom = new THREE.PlaneGeometry(1 + Math.random() * 3, 8 + Math.random() * 6);
                const riftMat = new THREE.MeshBasicMaterial({
                    color: 0x8800ff,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const rift = new THREE.Mesh(riftGeom, riftMat);
                rift.rotation.x = -Math.PI / 2;
                rift.rotation.z = Math.random() * Math.PI;
                rift.position.set(
                    (Math.random() - 0.5) * 80,
                    0.08,
                    (Math.random() - 0.5) * 80
                );
                scene.add(rift);
                biomeObjects.push(rift);

                // Add void energy pillar
                const pillarMat = new THREE.MeshBasicMaterial({ color: 0x6600cc, transparent: true, opacity: 0.4 });
                const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 1, 6, 6), pillarMat);
                pillar.position.copy(rift.position);
                pillar.position.y = 3;
                scene.add(pillar);
                biomeObjects.push(pillar);

                // Add void light
                const voidLight = new THREE.PointLight(0x8800ff, 0.6, 10);
                voidLight.position.copy(rift.position);
                voidLight.position.y = 1;
                scene.add(voidLight);
                biomeObjects.push(voidLight);
            }
        }

        // Transform terrain to heavenly realm
        function transformToHeavenlyRealm() {
            if (isHeavenlyRealm) return;
            isHeavenlyRealm = true;

            // Cleanup previous biome objects
            cleanupBiomeObjects();

            showError('âœ¨ THE HEAVENS OPEN... âœ¨');

            // Change ground to heavenly colors (bright gold/white) - TONED DOWN
            groundPlane.material.color.setHex(0xeeddcc); // Use slightly darker cream
            groundPlane.material.emissive = new THREE.Color(0xccaa66); // Darker gold emissive
            groundPlane.material.emissiveIntensity = 0.15; // Reduced from 0.3

            // Change scene background and fog (bright but not blinding)
            scene.background = new THREE.Color(0xffeecc); // Warmer, less harsh white
            scene.fog = new THREE.Fog(0xffeecc, 20, 100);

            // Change terrain objects to divine marble
            terrainObjects.forEach(obj => {
                obj.material = new THREE.MeshStandardMaterial({
                    color: 0xffffee,
                    emissive: 0xccaa66,
                    emissiveIntensity: 0.2, // Reduced from 0.4
                    roughness: 0.2,
                    metalness: 0.3
                });
            });

            // Add divine pillars and halos
            for (let i = 0; i < 15; i++) {
                // Golden halo rings on ground
                const haloGeom = new THREE.RingGeometry(2, 2.5, 16);
                const haloMat = new THREE.MeshBasicMaterial({
                    color: 0xffdd00,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const halo = new THREE.Mesh(haloGeom, haloMat);
                halo.rotation.x = -Math.PI / 2;
                halo.position.set(
                    (Math.random() - 0.5) * 80,
                    0.1,
                    (Math.random() - 0.5) * 80
                );
                scene.add(halo);
                biomeObjects.push(halo);

                // Light pillar rising from halo
                const pillarMat = new THREE.MeshBasicMaterial({ color: 0xffffcc, transparent: true, opacity: 0.3 });
                const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.8, 8, 8), pillarMat);
                pillar.position.copy(halo.position);
                pillar.position.y = 4;
                scene.add(pillar);
                biomeObjects.push(pillar);

                // Divine light
                const divineLight = new THREE.PointLight(0xffffaa, 0.8, 12);
                divineLight.position.copy(halo.position);
                divineLight.position.y = 2;
                scene.add(divineLight);
                biomeObjects.push(divineLight);
            }
        }

        // Transform terrain to cyber realm
        function transformToCyberRealm() {
            if (isCyberRealm) return;
            isCyberRealm = true;

            cleanupBiomeObjects();

            showError('ðŸ’¾ THE CYBER REALM AWAKENS... ðŸ’¾');

            // Change ground to cyber colors (dark blue/purple with glowing lines)
            groundPlane.material.color.setHex(0x0a0a1a);
            groundPlane.material.emissive = new THREE.Color(0x000033);
            groundPlane.material.emissiveIntensity = 0.5;

            // Change scene background and fog (dark blue/purple)
            scene.background = new THREE.Color(0x05050a);
            scene.fog = new THREE.Fog(0x05050a, 15, 70);

            // Change terrain objects to metallic/glowing structures
            terrainObjects.forEach(obj => {
                obj.material = new THREE.MeshStandardMaterial({
                    color: 0x1a1a2e,
                    emissive: 0x000055,
                    emissiveIntensity: 0.7,
                    roughness: 0.3,
                    metalness: 0.9
                });
            });

            // Add glowing cyber grids/lines on the ground
            for (let i = 0; i < 20; i++) {
                const lineMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                const lineGeom = new THREE.PlaneGeometry(1 + Math.random() * 5, 0.1);
                const line = new THREE.Mesh(lineGeom, lineMat);
                line.rotation.x = -Math.PI / 2;
                line.rotation.z = Math.random() * Math.PI;
                line.position.set(
                    (Math.random() - 0.5) * 80,
                    0.07,
                    (Math.random() - 0.5) * 80
                );
                scene.add(line);
                biomeObjects.push(line);

                // Add small glowing cubes/nodes
                const nodeMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1.0 });
                const node = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), nodeMat);
                node.position.set(
                    (Math.random() - 0.5) * 80,
                    0.25,
                    (Math.random() - 0.5) * 80
                );
                scene.add(node);
                biomeObjects.push(node);

                // Add cyber light
                const cyberLight = new THREE.PointLight(0x00ff00, 0.5, 8);
                cyberLight.position.copy(node.position);
                cyberLight.position.y = 1;
                scene.add(cyberLight);
                biomeObjects.push(cyberLight);
            }
        }

        const btnStartWave = document.getElementById('btnStartWave');
        const waveDisplay = document.getElementById('waveDisplay');

        btnStartWave.addEventListener('click', () => {
            if (waveState === 'IDLE') {
                startWave();
                btnStartWave.style.display = 'none'; // Hide after start, let it run
            }
        });

        function startWave() {
            waveState = 'SPAWNING';
            // Wave Logic: 5 + Wave Index enemies
            enemiesToSpawn = 5 + Math.floor(wave * 1.5);

            // Realm Transformations
            if (wave === 25) transformToLavaRealm();
            if (wave === 50) transformToIceRealm();
            if (wave === 75) transformToVoidRealm();
            if (wave === 100) transformToHeavenlyRealm();
            if (wave === 200) transformToCyberRealm();

            // Boss spawn check
            if (wave % 25 === 0) {
                spawnBoss();
            } else {
                enemiesToSpawn = 5 + Math.floor(wave * 1.2);
                waveState = 'SPAWNING';
            }

            // Wave Start Messages
            if (wave === 25) {
                showError("ðŸ”¥ THE LAVA REALM ðŸ”¥");
            } else if (wave === 50) {
                showError("â„ï¸ THE FROZEN REALM â„ï¸");
            } else if (wave === 75) {
                showError("ðŸ•³ï¸ THE VOID REALM ðŸ•³ï¸");
            } else if (wave === 100) {
                showError("âœ¨ THE HEAVENLY REALM âœ¨");
            } else if (wave === 200) {
                showError("ðŸ’¾ THE CYBER REALM ðŸ’¾");
            } else if (wave % 25 !== 0) {
                showError(`Wave ${wave} Started!`);
            }

            spawnTimer = 0;
            waveDisplay.textContent = wave;
        }

        // Create a small UI for errors
        const errorDiv = document.createElement('div');
        errorDiv.style.position = 'absolute';
        errorDiv.style.top = '50%';
        errorDiv.style.left = '50%';
        errorDiv.style.transform = 'translate(-50%, -50%)';
        errorDiv.style.color = '#ff4444';
        errorDiv.style.fontFamily = 'sans-serif';
        errorDiv.style.fontSize = '24px';
        errorDiv.style.fontWeight = 'bold';
        errorDiv.style.textShadow = '0 0 5px black';
        errorDiv.style.pointerEvents = 'none';
        errorDiv.style.opacity = '0';
        errorDiv.style.transition = 'opacity 0.5s';
        document.body.appendChild(errorDiv);

        function showError(msg) {
            errorDiv.textContent = msg;
            errorDiv.style.opacity = '1';
            setTimeout(() => errorDiv.style.opacity = '0', 1000);
        }

        // DEBUG TOAST (Bottom Right)
        const debugToast = document.createElement('div');
        debugToast.style.position = 'absolute';
        debugToast.style.bottom = '20px';
        debugToast.style.right = '20px';
        debugToast.style.padding = '10px 20px';
        debugToast.style.background = 'rgba(0,0,0,0.8)';
        debugToast.style.color = '#4ade80';
        debugToast.style.fontFamily = 'monospace';
        debugToast.style.fontSize = '16px';
        debugToast.style.borderRadius = '8px';
        debugToast.style.pointerEvents = 'none';
        debugToast.style.transition = 'opacity 0.3s';
        debugToast.style.opacity = '0';
        document.body.appendChild(debugToast);

        let debugMessages = [];
        function showDebug(msg) {
            debugMessages.push(msg);
            if (debugMessages.length > 10) debugMessages.shift(); // Keep last 10
            debugToast.innerHTML = debugMessages.join('<br>');
            debugToast.style.opacity = '1';
        }

        function isPointOnPath(x, z) {
            const point = new THREE.Vector3(x, 0, z);
            const threshold = 0.5; // Radius check (path is effectively 1 unit wide)

            for (let i = 0; i < pathNodes.length - 1; i++) {
                const a = pathNodes[i];
                const b = pathNodes[i + 1];

                // Line segment distance check
                const line = new THREE.Line3(a, b);
                const closest = new THREE.Vector3();
                line.closestPointToPoint(point, true, closest);

                if (closest.distanceTo(point) < threshold) {
                    return true;
                }
            }
            return false;
        }

        const terrainObjects = [];
        // selectedTower moved to top

        // Terrain Generation
        function generateTerrain() {
            const geom = new THREE.BoxGeometry(TILE_SIZE, 1, TILE_SIZE);
            const mat = new THREE.MeshStandardMaterial({ color: 0x64748b });

            let mountainsSpawned = 0;
            const targetMountains = 2;

            // Try to place mountains
            for (let attempt = 0; attempt < 1000; attempt++) {
                if (mountainsSpawned >= targetMountains) break;

                // Pick a center point
                let cx = Math.floor((Math.random() * 100 - 50) / TILE_SIZE) * TILE_SIZE;
                let cz = Math.floor((Math.random() * 100 - 50) / TILE_SIZE) * TILE_SIZE;

                const radius = 3; // 7x7 area for a wider, nicer hill
                const peakHeight = 10; // Peak height

                // Check constraints for the area
                let validLocation = true;

                // First pass: Validate area
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        const x = cx + (dx * TILE_SIZE);
                        const z = cz + (dz * TILE_SIZE);

                        // 1. Edge Constraint (Must be far from center)
                        if (Math.abs(x) < 35 && Math.abs(z) < 35) {
                            validLocation = false; break;
                        }

                        // 2. Map Bounds
                        if (Math.abs(x) > 65 || Math.abs(z) > 65) {
                            validLocation = false; break;
                        }

                        // 3. Path Safety
                        if (isPointOnPath(x, z)) {
                            validLocation = false; break;
                        }

                        // 4. Overlap Safety (Keep hills distinct for now)
                        if (terrainObjects.some(obj => Math.abs(obj.position.x - x) < 0.1 && Math.abs(obj.position.z - z) < 0.1)) {
                            validLocation = false; break;
                        }
                    }
                    if (!validLocation) break;
                }

                if (!validLocation) continue;

                // Second pass: Spawn blocks in stepped pyramid shape
                mountainsSpawned++;

                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        const x = cx + (dx * TILE_SIZE);
                        const z = cz + (dz * TILE_SIZE);

                        // Calculate height based on distance from center (Manhattan distance for pyramid, or random for noise)
                        // Let's use max(|dx|,|dz|) for concentric square rings (stepped pyramid)
                        const dist = Math.max(Math.abs(dx), Math.abs(dz));

                        // Peak is at dist 0. Height drops by 2 for each step out.
                        let height = peakHeight - (dist * 2);

                        // Optional: Add small random variation to make it look rugged, not perfect steps
                        // if (dist > 0) height += (Math.random() > 0.5 ? 1 : 0);

                        if (height <= 2) continue; // Too low, blend with ground

                        const mesh = new THREE.Mesh(geom, mat);
                        mesh.scale.set(1, height, 1);
                        mesh.position.set(x, height / 2, z);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData = { isTerrain: true, height: height };

                        scene.add(mesh);
                        terrainObjects.push(mesh);
                    }
                }
            }
            console.log("Spawned mountains:", mountainsSpawned);
        }
        generateTerrain(); // Call at startup

        // Tower Selection UI


        // Procedural Mesh Generators
        function createScoutMesh(level = 1) {
            const group = new THREE.Group();

            // Level-based progression:
            // Lvl 1-2: Basic scout (yellow/blue)
            // Lvl 3-4: Tactical (green, helmet, armor)
            // Lvl 5-6: Elite (gold trim, dual pistols, cape)
            // Lvl 7-9: Shadow operative (dark with glowing elements)
            // Lvl 10: Legendary (golden aura, energy weapons)

            const tier = level >= 10 ? 5 : (level >= 7 ? 4 : (level >= 5 ? 3 : (level >= 3 ? 2 : 1)));

            // Colors based on tier
            const skinColors = [0xfacc15, 0x90ee90, 0xffd700, 0x4a4a6a, 0xfff8dc];
            const shirtColors = [0x3b82f6, 0x22543d, 0x1a1a2e, 0x1a0a2e, 0xffd700];
            const pantsColors = [0x1e293b, 0x1e3a2f, 0x2d2d44, 0x0a0a1a, 0x1a1a2e];
            const gunColors = [0x94a3b8, 0x2f4f4f, 0xffd700, 0x6600ff, 0x00ffff];

            const matSkin = new THREE.MeshLambertMaterial({ color: skinColors[tier - 1] });
            const matShirt = new THREE.MeshLambertMaterial({ color: shirtColors[tier - 1] });
            const matPants = new THREE.MeshLambertMaterial({ color: pantsColors[tier - 1] });
            const matGun = new THREE.MeshLambertMaterial({ color: gunColors[tier - 1] });

            // Legs - get armored at higher levels
            const legArmor = level >= 5 ? 0.1 : 0;
            const LegL = new THREE.Mesh(new THREE.BoxGeometry(0.5 + legArmor, 1.2, 0.5 + legArmor), matPants);
            LegL.position.set(-0.3, 0.6, 0);
            LegL.castShadow = true;
            group.add(LegL);

            const LegR = new THREE.Mesh(new THREE.BoxGeometry(0.5 + legArmor, 1.2, 0.5 + legArmor), matPants);
            LegR.position.set(0.3, 0.6, 0);
            LegR.castShadow = true;
            group.add(LegR);

            // Knee pads at level 3+
            if (level >= 3) {
                const kneeMat = new THREE.MeshLambertMaterial({ color: tier >= 3 ? 0xffd700 : 0x333333 });
                const kneeL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.2, 0.15), kneeMat);
                kneeL.position.set(-0.3, 0.5, 0.3);
                group.add(kneeL);
                const kneeR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.2, 0.15), kneeMat);
                kneeR.position.set(0.3, 0.5, 0.3);
                group.add(kneeR);
            }

            // Torso - gets bulkier with level
            const torsoWidth = 1.2 + (level * 0.05);
            const torso = new THREE.Mesh(new THREE.BoxGeometry(torsoWidth, 1.2, 0.6), matShirt);
            torso.position.set(0, 1.8, 0);
            torso.castShadow = true;
            group.add(torso);

            // Body armor at level 4+
            if (level >= 4) {
                const armorMat = new THREE.MeshStandardMaterial({
                    color: tier >= 4 ? 0x6600cc : 0x444444,
                    metalness: 0.7,
                    roughness: 0.3,
                    emissive: tier >= 4 ? 0x220044 : 0x000000,
                    emissiveIntensity: 0.3
                });
                const chestPlate = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.8, 0.2), armorMat);
                chestPlate.position.set(0, 1.85, 0.4);
                group.add(chestPlate);
            }

            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), matSkin);
            head.position.set(0, 2.8, 0);
            head.castShadow = true;
            group.add(head);

            // Headgear progression
            if (level >= 7) {
                // Full tactical helmet with glow
                const helmetMat = new THREE.MeshStandardMaterial({
                    color: tier === 5 ? 0xffd700 : 0x1a1a2e,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const helmet = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.6, 0.95), helmetMat);
                helmet.position.set(0, 3.0, 0);
                group.add(helmet);

                // Glowing visor
                const visorMat = new THREE.MeshBasicMaterial({ color: tier === 5 ? 0x00ffff : 0xff0000 });
                const visor = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.15, 0.1), visorMat);
                visor.position.set(0, 2.9, 0.48);
                group.add(visor);

                // Antenna
                const antenna = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.4, 6), helmetMat);
                antenna.position.set(0.4, 3.4, 0);
                group.add(antenna);
            } else if (level >= 3) {
                // Tactical helmet
                const helmet = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.4, 0.9), matShirt);
                helmet.position.set(0, 3.15, 0);
                group.add(helmet);

                const visorMat = new THREE.MeshBasicMaterial({ color: tier >= 3 ? 0xff4400 : 0x00ff00 });
                const visor = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.15, 0.1), visorMat);
                visor.position.set(0, 2.95, 0.41);
                group.add(visor);
            } else {
                // Basic cap
                const cap = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.2, 0.85), matShirt);
                cap.position.set(0, 3.25, 0);
                group.add(cap);
            }

            // Arms
            const ArmL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.0, 0.4), matShirt);
            ArmL.position.set(-0.8, 1.8, 0);
            group.add(ArmL);
            const HandL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), matSkin);
            HandL.position.set(-0.8, 1.1, 0);
            group.add(HandL);

            const ArmR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.0, 0.4), matShirt);
            ArmR.position.set(0.8, 1.8, 0.2);
            ArmR.rotation.x = -Math.PI / 2;
            group.add(ArmR);
            const HandR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), matSkin);
            HandR.position.set(0.8, 1.8, 0.9);
            group.add(HandR);

            // Primary Pistol - size increases with level
            const gunScale = 1 + (level * 0.1);
            const gunMain = new THREE.Mesh(new THREE.BoxGeometry(0.2 * gunScale, 0.3 * gunScale, 0.8 * gunScale), matGun);
            gunMain.position.set(0.8, 2.0, 1.2);
            group.add(gunMain);
            const gunHandle = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), matGun);
            gunHandle.position.set(0.8, 1.7, 0.9);
            group.add(gunHandle);

            // Dual pistols at level 5+
            if (level >= 5) {
                const gun2Main = new THREE.Mesh(new THREE.BoxGeometry(0.2 * gunScale, 0.3 * gunScale, 0.8 * gunScale), matGun);
                gun2Main.position.set(-0.8, 1.3, 0.4);
                group.add(gun2Main);
            }

            // Cape at level 5+ (gets more elaborate)
            if (level >= 5) {
                const capeColor = tier === 5 ? 0xffd700 : (tier === 4 ? 0x4400aa : 0x8b0000);
                const capeMat = new THREE.MeshLambertMaterial({ color: capeColor, side: THREE.DoubleSide });
                const capeHeight = 1.5 + (level - 5) * 0.1;
                const cape = new THREE.Mesh(new THREE.PlaneGeometry(1.0 + (level - 5) * 0.1, capeHeight), capeMat);
                cape.position.set(0, 1.5, -0.35);
                cape.rotation.x = 0.2;
                group.add(cape);
            }

            // Energy aura at level 7+
            if (level >= 7) {
                const auraColor = tier === 5 ? 0xffd700 : 0x6600cc;
                const auraMat = new THREE.MeshBasicMaterial({ color: auraColor, transparent: true, opacity: 0.2 });
                const aura = new THREE.Mesh(new THREE.SphereGeometry(1.8, 16, 16), auraMat);
                aura.position.set(0, 1.8, 0);
                group.add(aura);

                // Point light for glow
                const light = new THREE.PointLight(auraColor, 0.5, 4);
                light.position.set(0, 2, 0);
                group.add(light);
            }

            // Legendary crown at level 10
            if (level >= 10) {
                const crownMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 1, roughness: 0.2, emissive: 0xffaa00, emissiveIntensity: 0.5 });
                const crownBase = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.5, 0.2, 8), crownMat);
                crownBase.position.set(0, 3.5, 0);
                group.add(crownBase);
                // Crown spikes
                for (let i = 0; i < 5; i++) {
                    const spike = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.3, 4), crownMat);
                    spike.position.set(Math.cos(i * Math.PI * 2 / 5) * 0.35, 3.7, Math.sin(i * Math.PI * 2 / 5) * 0.35);
                    group.add(spike);
                }
            }

            // Face (only visible at lower levels without full helmet)
            if (level < 7) {
                const matBlack = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.05), matBlack);
                eyeL.position.set(-0.2, 2.9, 0.41);
                group.add(eyeL);
                const eyeR = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.05), matBlack);
                eyeR.position.set(0.2, 2.9, 0.41);
                group.add(eyeR);
            }

            // Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.5, 1.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            hitbox.position.set(0, 1.75, 0);
            hitbox.userData = { isHitbox: true };
            group.add(hitbox);

            return group;
        }

        function createSniperMesh(level = 1) {
            const group = new THREE.Group();

            // Level-based progression:
            // Lvl 1-2: Standard tactical (grey) 
            // Lvl 3-4: Desert ops (tan, larger scope, vest)
            // Lvl 5-6: Arctic elite (white, gold trim, ghillie)
            // Lvl 7-9: Void hunter (dark purple, energy rifle, cloak)
            // Lvl 10: Legendary marksman (golden, plasma cannon, floating)

            const tier = level >= 10 ? 5 : (level >= 7 ? 4 : (level >= 5 ? 3 : (level >= 3 ? 2 : 1)));

            // Colors based on tier
            const clothesDarkColors = [0x334155, 0x8b7355, 0xf0f0f0, 0x1a0a2e, 0x1a1a2e];
            const clothesLightColors = [0x64748b, 0xd2b48c, 0xffffff, 0x4a2a6a, 0xffd700];
            const gunBodyColors = [0x94a3b8, 0x654321, 0xffd700, 0x6600cc, 0x00ffff];
            const glassColors = [0xf59e0b, 0x00ff00, 0xff0000, 0xff00ff, 0x00ffff];

            const matSkin = new THREE.MeshLambertMaterial({ color: tier === 5 ? 0xffeecc : 0xffdcb1 });
            const matClothesDark = new THREE.MeshLambertMaterial({ color: clothesDarkColors[tier - 1] });
            const matClothesLight = new THREE.MeshLambertMaterial({ color: clothesLightColors[tier - 1] });
            const matBlack = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const matGunBody = new THREE.MeshStandardMaterial({
                color: gunBodyColors[tier - 1],
                metalness: tier >= 4 ? 0.9 : 0.3,
                roughness: tier >= 4 ? 0.2 : 0.7,
                emissive: tier >= 4 ? gunBodyColors[tier - 1] : 0x000000,
                emissiveIntensity: tier >= 4 ? 0.3 : 0
            });
            const matGlass = new THREE.MeshBasicMaterial({ color: glassColors[tier - 1] });

            // Legs - more armored at higher tiers
            const legWidth = 0.5 + (tier >= 3 ? 0.1 : 0);
            const LegL = new THREE.Mesh(new THREE.BoxGeometry(legWidth, 1.2, 0.6), matClothesDark);
            LegL.position.set(-0.4, 0.6, 0);
            LegL.castShadow = true;
            group.add(LegL);

            const LegR = new THREE.Mesh(new THREE.BoxGeometry(legWidth, 1.2, 0.6), matClothesDark);
            LegR.position.set(0.4, 0.6, 0);
            LegR.castShadow = true;
            group.add(LegR);

            // Torso - larger at higher levels
            const torsoSize = 1.3 + (level * 0.03);
            const torso = new THREE.Mesh(new THREE.BoxGeometry(torsoSize, 1.2, 0.7), matClothesDark);
            torso.position.set(0, 1.8, 0);
            torso.castShadow = true;
            group.add(torso);

            // Armor vest progression
            if (level >= 3) {
                const vestColor = tier === 5 ? 0xffd700 : (tier === 4 ? 0x4400aa : (tier === 3 ? 0xffd700 : 0x556b2f));
                const vestMat = new THREE.MeshStandardMaterial({
                    color: vestColor,
                    metalness: tier >= 3 ? 0.6 : 0.2,
                    roughness: 0.4
                });
                const vest = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.8, 0.5), vestMat);
                vest.position.set(0, 1.9, 0.15);
                group.add(vest);
            }

            // Shoulder pads at level 5+
            if (level >= 5) {
                const padMat = new THREE.MeshStandardMaterial({
                    color: tier === 5 ? 0xffd700 : (tier === 4 ? 0x6600cc : 0xcccccc),
                    metalness: 0.8,
                    roughness: 0.2
                });
                const padL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.25, 0.5), padMat);
                padL.position.set(-0.75, 2.3, 0);
                group.add(padL);
                const padR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.25, 0.5), padMat);
                padR.position.set(0.75, 2.3, 0);
                group.add(padR);
            }

            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), matSkin);
            head.position.set(0, 2.85, 0);
            head.castShadow = true;
            group.add(head);

            // Headgear progression
            if (level >= 7) {
                // Full tactical helmet
                const helmetMat = new THREE.MeshStandardMaterial({
                    color: tier === 5 ? 0xffd700 : 0x1a0a2e,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const helmet = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.6, 1.0), helmetMat);
                helmet.position.set(0, 3.15, 0);
                group.add(helmet);

                // Night vision goggles
                const nvgMat = new THREE.MeshBasicMaterial({ color: tier === 5 ? 0x00ffff : 0x00ff00 });
                const nvgL = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.3, 8), nvgMat);
                nvgL.rotation.x = Math.PI / 2;
                nvgL.position.set(-0.25, 2.95, 0.5);
                group.add(nvgL);
                const nvgR = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.3, 8), nvgMat);
                nvgR.rotation.x = Math.PI / 2;
                nvgR.position.set(0.25, 2.95, 0.5);
                group.add(nvgR);
            } else {
                // Cap
                const cap = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.3, 1.0), matClothesDark);
                cap.position.set(0, 3.3, 0);
                group.add(cap);

                // Sunglasses
                const glasses = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.25, 0.1), matGlass);
                glasses.position.set(0, 2.9, 0.46);
                group.add(glasses);
            }

            // Headphones
            const phoneL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, 0.4), matBlack);
            phoneL.position.set(-0.55, 2.85, 0);
            group.add(phoneL);
            const phoneR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, 0.4), matBlack);
            phoneR.position.set(0.55, 2.85, 0);
            group.add(phoneR);
            const phoneBand = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.2), matBlack);
            phoneBand.position.set(0, 3.35, 0);
            group.add(phoneBand);

            // Arms
            const ArmL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.2, 0.4), matClothesLight);
            ArmL.position.set(-0.6, 2.0, 0.6);
            ArmL.rotation.x = -Math.PI / 2;
            ArmL.rotation.z = -0.2;
            group.add(ArmL);

            const ArmR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.2, 0.4), matClothesLight);
            ArmR.position.set(0.6, 2.0, 0.4);
            ArmR.rotation.x = -Math.PI / 2;
            ArmR.rotation.z = 0.2;
            group.add(ArmR);

            // --- RIFLE ---
            const rifleGroup = new THREE.Group();

            // Main Body - longer and more impressive at higher levels
            const rifleLength = 1.5 + (level * 0.2);
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, rifleLength), matGunBody);
            body.position.set(0, 0, 0);
            rifleGroup.add(body);

            // Barrel - gets longer and more elaborate
            const barrelLength = 2.5 + (level * 0.4);
            const barrelRadius = tier >= 4 ? 0.1 : 0.08;
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(barrelRadius, barrelRadius, barrelLength, 8), matBlack);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0.1, rifleLength / 2 + barrelLength / 2);
            rifleGroup.add(barrel);

            // Muzzle Brake - more elaborate at higher levels
            if (tier >= 3) {
                const muzzleMat = new THREE.MeshStandardMaterial({ color: tier === 5 ? 0xffd700 : 0x333333, metalness: 0.9, roughness: 0.2 });
                const muzzle = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.5), muzzleMat);
                muzzle.position.set(0, 0.1, rifleLength / 2 + barrelLength + 0.25);
                rifleGroup.add(muzzle);
            } else {
                const muzzle = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.4), matBlack);
                muzzle.position.set(0, 0.1, rifleLength / 2 + barrelLength + 0.2);
                rifleGroup.add(muzzle);
            }

            // Scope - progressively larger and more advanced
            const scopeSize = 0.12 + (level * 0.02);
            const scopeLength = 0.8 + (level * 0.15);
            const scope = new THREE.Mesh(new THREE.CylinderGeometry(scopeSize, scopeSize + 0.03, scopeLength, 16), matBlack);
            scope.rotation.x = Math.PI / 2;
            scope.position.set(0, 0.4, 0.2);
            rifleGroup.add(scope);

            // Scope glow at level 3+
            if (level >= 3) {
                const glowColor = tier === 5 ? 0x00ffff : (tier === 4 ? 0xff00ff : 0xff0000);
                const scopeGlowMat = new THREE.MeshBasicMaterial({ color: glowColor });
                const scopeGlow = new THREE.Mesh(new THREE.SphereGeometry(scopeSize * 0.6, 8, 8), scopeGlowMat);
                scopeGlow.position.set(0, 0.4, 0.2 + scopeLength / 2);
                rifleGroup.add(scopeGlow);
            }

            // Laser sight at level 5+
            if (level >= 5) {
                const laserColor = tier === 5 ? 0x00ffff : 0xff0000;
                const laserMat = new THREE.MeshBasicMaterial({ color: laserColor });
                const laser = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 15, 6), laserMat);
                laser.rotation.x = Math.PI / 2;
                laser.position.set(0.15, 0.2, 8);
                rifleGroup.add(laser);
            }

            // Stock
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.8), matBlack);
            stock.position.set(0, -0.1, -rifleLength / 2 - 0.4);
            rifleGroup.add(stock);

            // Position Rifle
            rifleGroup.position.set(0, 2.1, 0.5);
            group.add(rifleGroup);

            // Ghillie suit at level 5+
            if (level >= 5) {
                const ghillieColor = tier === 5 ? 0xffd700 : (tier === 4 ? 0x4a2a6a : 0x228b22);
                const ghillieMat = new THREE.MeshLambertMaterial({ color: ghillieColor, side: THREE.DoubleSide });
                const strandCount = 8 + (level - 5) * 2;
                for (let i = 0; i < strandCount; i++) {
                    const strand = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 0.6 + Math.random() * 0.3), ghillieMat);
                    strand.position.set(
                        (Math.random() - 0.5) * 1.4,
                        1.5 + Math.random() * 1.2,
                        -0.4 - Math.random() * 0.2
                    );
                    strand.rotation.y = Math.random() * Math.PI;
                    strand.rotation.z = (Math.random() - 0.5) * 0.3;
                    group.add(strand);
                }
            }

            // Energy cloak at level 7+
            if (level >= 7) {
                const cloakColor = tier === 5 ? 0xffd700 : 0x6600cc;
                const cloakMat = new THREE.MeshBasicMaterial({ color: cloakColor, transparent: true, opacity: 0.25, side: THREE.DoubleSide });
                const cloak = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 2.2), cloakMat);
                cloak.position.set(0, 1.5, -0.5);
                cloak.rotation.x = 0.3;
                group.add(cloak);

                // Energy glow
                const light = new THREE.PointLight(cloakColor, 0.6, 4);
                light.position.set(0, 2, 0);
                group.add(light);
            }

            // Legendary floating platform at level 10
            if (level >= 10) {
                const platMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 1, roughness: 0.1, emissive: 0xffaa00, emissiveIntensity: 0.5 });
                const platform = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.0, 0.15, 8), platMat);
                platform.position.set(0, -0.1, 0);
                group.add(platform);

                // Floating runes
                for (let i = 0; i < 4; i++) {
                    const runeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                    const rune = new THREE.Mesh(new THREE.RingGeometry(0.15, 0.2, 6), runeMat);
                    rune.position.set(
                        Math.cos(i * Math.PI / 2) * 1.3,
                        0.5 + Math.random() * 0.5,
                        Math.sin(i * Math.PI / 2) * 1.3
                    );
                    rune.rotation.x = Math.PI / 2;
                    group.add(rune);
                }
            }

            // Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.5, 1.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            hitbox.position.set(0, 1.75, 0);
            hitbox.userData = { isHitbox: true };
            group.add(hitbox);

            return group;
        }

        function createPyroMesh(level = 1) {
            const group = new THREE.Group();

            // Level-based colors
            // Lvl 1: Dark red robe, orange fire
            // Lvl 2: Purple robe, blue fire, shoulder pads
            // Lvl 3: Black robe with gold trim, white-hot fire, floating runes

            const robeColor = level === 3 ? 0x1a1a2e : (level === 2 ? 0x4a1942 : 0x7c2d12);
            const fireColor = level === 3 ? 0xffffff : (level === 2 ? 0x3b82f6 : 0xff4400);
            const fireEmissive = level === 3 ? 0xffffaa : (level === 2 ? 0x60a5fa : 0xff5500);
            const trimColor = level === 3 ? 0xffd700 : (level === 2 ? 0xa855f7 : 0xf97316);

            const matRobe = new THREE.MeshStandardMaterial({ color: robeColor, roughness: 0.9 });
            const matTrim = new THREE.MeshStandardMaterial({ color: trimColor, roughness: 0.6, emissive: trimColor, emissiveIntensity: 0.3 * level });
            const matSkin = new THREE.MeshStandardMaterial({ color: 0xfca5a5, roughness: 0.8 });
            const matStaff = new THREE.MeshStandardMaterial({ color: level === 3 ? 0x8b5a2b : 0x451a03, roughness: 1.0 });
            const matFire = new THREE.MeshStandardMaterial({ color: fireColor, emissive: fireEmissive, emissiveIntensity: 2.0 + level, transparent: true, opacity: 0.9 });

            // Robe Body - taller at higher levels
            const robeHeight = 1.8 + (level * 0.2);
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.6, robeHeight, 8), matRobe);
            body.position.set(0, robeHeight / 2, 0);
            body.castShadow = true;
            group.add(body);

            // Trim at bottom of robe
            const trimRing = new THREE.Mesh(new THREE.TorusGeometry(0.55, 0.08, 8, 16), matTrim);
            trimRing.rotation.x = Math.PI / 2;
            trimRing.position.set(0, 0.1, 0);
            group.add(trimRing);

            // Head (Hooded)
            const hood = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), matRobe);
            hood.position.set(0, robeHeight + 0.3, 0);
            hood.castShadow = true;
            group.add(hood);

            const face = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), matSkin);
            face.position.set(0, robeHeight + 0.3, 0.15);
            group.add(face);

            // Shoulder pads at level 2+
            if (level >= 2) {
                const shoulderL = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), matTrim);
                shoulderL.position.set(-0.5, robeHeight - 0.2, 0);
                group.add(shoulderL);

                const shoulderR = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), matTrim);
                shoulderR.position.set(0.5, robeHeight - 0.2, 0);
                group.add(shoulderR);
            }

            // Staff - more ornate at higher levels
            const staffLength = 2.5 + (level * 0.3);
            const staffHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.07, staffLength), matStaff);
            staffHandle.position.set(0.6, staffLength / 2 + 0.3, 0.5);
            staffHandle.rotation.x = 0.2;
            group.add(staffHandle);

            // Orb on staff - bigger with level
            const orbSize = 0.25 + (level * 0.1);
            const orb = new THREE.Mesh(new THREE.SphereGeometry(orbSize, 16, 16), matFire);
            orb.position.set(0.6, staffLength + 0.5, 0.7);
            group.add(orb);

            // Multiple orbs at level 3
            if (level === 3) {
                const orb2 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), matFire);
                orb2.position.set(0.3, staffLength + 0.3, 0.5);
                group.add(orb2);

                const orb3 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), matFire);
                orb3.position.set(0.9, staffLength + 0.3, 0.5);
                group.add(orb3);
            }

            // Light from staff - brighter with level
            const light = new THREE.PointLight(fireEmissive, 2 + level, 5 + level * 2);
            light.position.set(0.6, staffLength + 0.5, 0.7);
            group.add(light);

            // Floating runes at level 3+
            if (level >= 3) {
                const runeScale = 1 + (level - 3) * 0.1; // Grows with level
                const runeGeom = new THREE.RingGeometry(0.8 * runeScale, 1.0 * runeScale, 6);
                const runeMat = new THREE.MeshBasicMaterial({ color: 0xffd700, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                const rune = new THREE.Mesh(runeGeom, runeMat);
                rune.rotation.x = Math.PI / 2;
                rune.position.set(0, 0.3, 0);
                group.add(rune);

                // Extra runes at level 5+
                if (level >= 5) {
                    const rune2 = rune.clone();
                    rune2.position.y = 0.6;
                    rune2.scale.set(0.8, 0.8, 0.8);
                    group.add(rune2);
                }
            }

            // Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.0, 1.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            hitbox.position.set(0, 1.5, 0);
            hitbox.userData = { isHitbox: true };
            group.add(hitbox);

            return group;
        }

        function createTeslaMesh(level = 1) {
            const group = new THREE.Group();

            // Materials
            // Lvl 3+ = Gold Plating
            const metalColor = level >= 3 ? 0xffd700 : 0x94a3b8;
            const coreColor = level >= 3 ? 0xa855f7 : 0x00ffff; // Purple vs Cyan core

            const matMetal = new THREE.MeshStandardMaterial({ color: metalColor, metalness: level >= 3 ? 1.0 : 0.9, roughness: 0.2 });
            const matCoil = new THREE.MeshStandardMaterial({ color: 0xb8c0ff, metalness: 0.8, roughness: 0.3 });
            const matEnergy = new THREE.MeshStandardMaterial({ color: coreColor, emissive: coreColor, emissiveIntensity: 2.0 + level });

            // Base platform
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.0, 0.5, 8), matMetal);
            base.position.set(0, 0.25, 0);
            base.castShadow = true;
            group.add(base);

            // Pillar
            const height = 1.5 + ((level - 1) * 0.5); // Taller per level
            const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, height, 8), matMetal);
            pillar.position.set(0, 0.25 + (height / 2), 0);
            group.add(pillar);

            // Coils (Rings)
            const ringCount = 2 + level; // 3, 4, 5 rings
            for (let i = 0; i < ringCount; i++) {
                const ring = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.08, 8, 16), matCoil);
                ring.rotation.x = Math.PI / 2;
                const yPos = 0.8 + (i * (height / ringCount));
                ring.position.set(0, yPos, 0);
                group.add(ring);
            }

            // Top Orb
            const orb = new THREE.Mesh(new THREE.SphereGeometry(0.5 + (level * 0.1), 16, 16), matEnergy);
            orb.position.set(0, 0.25 + height + 0.5, 0);
            group.add(orb);

            // Ambient glow
            const light = new THREE.PointLight(coreColor, 1.5 + level, 4 + level);
            light.position.set(0, 0.25 + height + 0.5, 0);
            group.add(light);

            // Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.5, 1.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            hitbox.position.set(0, 1.75, 0);
            hitbox.userData = { isHitbox: true };
            group.add(hitbox);

            return group;
        }

        // --- NEW TOWER MESHES ---

        function createGlacierMesh(level = 1) {
            const group = new THREE.Group();

            // Materials (Ice/Crystal look)
            const iceColor = level === 3 ? 0xccffff : 0x00ffff;
            const matIce = new THREE.MeshStandardMaterial({
                color: iceColor,
                transparent: true,
                opacity: 0.8,
                roughness: 0.1,
                metalness: 0.1,
                emissive: 0x0044ff,
                emissiveIntensity: 0.3 * level
            });
            const matBase = new THREE.MeshStandardMaterial({ color: 0xeeeeee });

            // Base
            const base = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.2, 0.4, 6), matBase);
            base.position.y = 0.2;
            group.add(base);

            // Shards (Random crystal growth look)
            const shardCount = 3 + level * 2;
            for (let i = 0; i < shardCount; i++) {
                const height = 1 + Math.random() + (level * 0.3);
                const shard = new THREE.Mesh(new THREE.ConeGeometry(0.3, height, 4), matIce);
                shard.position.set(
                    (Math.random() - 0.5) * 1,
                    0.4 + height / 2,
                    (Math.random() - 0.5) * 1
                );
                shard.rotation.x = (Math.random() - 0.5) * 0.5;
                shard.rotation.z = (Math.random() - 0.5) * 0.5;
                group.add(shard);
            }

            // Central Spire
            const spire = new THREE.Mesh(new THREE.ConeGeometry(0.5, 3 + level, 5), matIce);
            spire.position.y = 1.5 + level / 2;
            group.add(spire);

            // Cold particles (simple cubes)
            if (level >= 2) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                p.position.set(0, 3, 0);
                group.add(p);
            }

            return group;
        }

        function createRocketMesh(level = 1) {
            const group = new THREE.Group();

            const metalColor = 0x2f4f4f; // Dark slate grey
            const detailColor = 0x22c55e; // Green
            const matMetal = new THREE.MeshStandardMaterial({ color: metalColor, roughness: 0.5, metalness: 0.8 });
            const matDetail = new THREE.MeshStandardMaterial({ color: detailColor });

            // Heavy Base
            const base = new THREE.Mesh(new THREE.BoxGeometry(2, 0.5, 2), matMetal);
            base.position.y = 0.25;
            group.add(base);

            // Turret Swivel
            const swivel = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.5, 16), matMetal);
            swivel.position.y = 0.75;
            group.add(swivel);

            // Missile Pods
            const podWidth = 0.6 + (level * 0.1);
            const podL = new THREE.Mesh(new THREE.BoxGeometry(podWidth, 1, 1.5), matMetal);
            podL.position.set(-0.8, 1.5, 0);
            group.add(podL);

            const podR = new THREE.Mesh(new THREE.BoxGeometry(podWidth, 1, 1.5), matMetal);
            podR.position.set(0.8, 1.5, 0);
            group.add(podR);

            // Missiles (Tips sticking out)
            const missileGeom = new THREE.ConeGeometry(0.1, 0.3, 8);
            const missileMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            const mCount = level * 2;
            for (let i = 0; i < mCount; i++) {
                const m = new THREE.Mesh(missileGeom, missileMat);
                m.rotation.x = -Math.PI / 2;
                m.position.set(-0.8 + (Math.random() - 0.5) * 0.3, 1.5 + (Math.random() - 0.5) * 0.3, 0.8);
                group.add(m);

                const m2 = m.clone();
                m2.position.set(0.8 + (Math.random() - 0.5) * 0.3, 1.5 + (Math.random() - 0.5) * 0.3, 0.8);
                group.add(m2);
            }

            return group;
        }

        function createAmplifierMesh(level = 1) {
            const group = new THREE.Group();

            const matDark = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.5 });
            const matGlow = new THREE.MeshStandardMaterial({ color: 0xa855f7, emissive: 0xa855f7, emissiveIntensity: 2 });

            // Tower
            const tower = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.8, 3, 4), matDark);
            tower.position.y = 1.5;
            group.add(tower);

            // Dish/Pulse Emitter
            const dish = new THREE.Mesh(new THREE.CylinderGeometry(1 + level * 0.2, 0.1, 0.5, 16), matDark);
            dish.position.y = 3;
            group.add(dish);

            // Floating Crystal
            const crystal = new THREE.Mesh(new THREE.OctahedronGeometry(0.4 + level * 0.1), matGlow);
            crystal.position.y = 3.8;
            group.add(crystal);

            // Pulse rings
            if (level >= 2) {
                const ring = new THREE.Mesh(new THREE.TorusGeometry(0.8, 0.05, 8, 32), matGlow);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 2;
                group.add(ring);
            }

            return group;
        }

        function createRailgunMesh(level = 1) {
            const group = new THREE.Group();

            const matSilver = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 1.0, roughness: 0.2 });
            const matRed = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 1 });

            // Tripod Legs
            const legGeom = new THREE.BoxGeometry(0.2, 1.5, 0.2);
            const leg1 = new THREE.Mesh(legGeom, matSilver);
            leg1.position.set(0.8, 0.75, 0.8);
            leg1.rotation.z = -0.3;
            leg1.rotation.x = 0.3;
            group.add(leg1);

            const leg2 = new THREE.Mesh(legGeom, matSilver);
            leg2.position.set(-0.8, 0.75, 0.8);
            leg2.rotation.z = 0.3;
            leg2.rotation.x = 0.3;
            group.add(leg2);

            const leg3 = new THREE.Mesh(legGeom, matSilver);
            leg3.position.set(0, 0.75, -0.8);
            leg3.rotation.x = -0.3;
            group.add(leg3);

            // Main Gun
            const barrelLen = 3 + level * 0.5;
            const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 1.5), matSilver);
            gunBody.position.set(0, 1.8, 0);
            group.add(gunBody);

            // Long Barrel
            const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, barrelLen), matSilver);
            barrel.position.set(0, 1.8, barrelLen / 2);
            group.add(barrel);

            // Coils
            for (let i = 0; i < 4 + level; i++) {
                const coil = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.1), matRed);
                coil.position.set(0, 1.8, 1 + (i * 0.5));
                group.add(coil);
            }

            return group;
        }

        function createNanominerMesh(level = 1) {
            const group = new THREE.Group();

            const matOrange = new THREE.MeshStandardMaterial({ color: 0xffaa00, metalness: 0.6 });
            const matDark = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const matHolo = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.4, wireframe: true });

            // Drilling Rig Base
            const base = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 2), matDark);
            base.position.y = 0.1;
            group.add(base);

            // Drill bit (always rotating?)
            const drill = new THREE.Mesh(new THREE.ConeGeometry(0.5, 2, 8), matOrange);
            drill.rotation.x = Math.PI;
            drill.position.y = 1;
            group.add(drill);

            // Scaffold
            const leg1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.5, 0.1), matDark);
            leg1.position.set(0.8, 1.25, 0.8);
            group.add(leg1);
            const leg2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.5, 0.1), matDark);
            leg2.position.set(-0.8, 1.25, 0.8);
            group.add(leg2);
            const leg3 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.5, 0.1), matDark);
            leg3.position.set(0.8, 1.25, -0.8);
            group.add(leg3);
            const leg4 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.5, 0.1), matDark);
            leg4.position.set(-0.8, 1.25, -0.8);
            group.add(leg4);

            // Holographic data
            if (level >= 2) {
                const cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), matHolo);
                cube.position.y = 2.5;
                group.add(cube);
            }

            return group;
        }

        // Stats UI Refs
        const uiPanel = document.getElementById('statsPanel');
        uiPanel.style.display = 'none'; // Start hidden
        const uiName = document.getElementById('refName');
        const uiRange = document.getElementById('refRange');
        const uiDamage = document.getElementById('refDamage');
        const uiSpeed = document.getElementById('refSpeed');
        const uiKills = document.getElementById('refKills');
        document.getElementById('btnCloseStats').onclick = () => {
            selectedPlacedTower = null;
            uiPanel.style.display = 'none';
            selectionRing.visible = false;
        };

        const btnUpgrade = document.getElementById('btnUpgrade');
        const refLevel = document.getElementById('refLevel');

        btnUpgrade.addEventListener('click', () => {
            if (!selectedPlacedTower) return;
            const t = selectedPlacedTower;

            // Safety check for level
            if (!t.level) t.level = 1;
            if (!t.maxLevel) t.maxLevel = 3;

            if (t.level >= t.maxLevel) {
                showError("Max Level Reached!");
                return;
            }

            // Check upgrade cost
            const upgradeCost = getUpgradeCost(t);
            if (money < upgradeCost) {
                showError(`Need $${upgradeCost} to upgrade!`);
                return;
            }

            // Spend money
            spendMoney(upgradeCost);

            // Upgrade Logic
            t.level++;
            t.damage *= 1.5; // 50% Damage boost
            t.range += 2;    // Slight range boost
            t.cooldown *= 0.9; // 10% Faster

            // Visual Update (Re-mesh)
            const oldPos = t.mesh.position.clone();
            const oldRot = t.mesh.rotation.clone();
            scene.remove(t.mesh);

            let newMesh;
            if (t.type === 'sniper') newMesh = createSniperMesh(t.level);
            if (t.type === 'pyro') newMesh = createPyroMesh(t.level);
            if (t.type === 'tesla') newMesh = createTeslaMesh(t.level);
            if (t.type === 'scout') newMesh = createScoutMesh(t.level);
            // New Towers
            if (t.type === 'glacier') newMesh = createGlacierMesh(t.level);
            if (t.type === 'rocket') newMesh = createRocketMesh(t.level);
            if (t.type === 'amp') newMesh = createAmplifierMesh(t.level);
            if (t.type === 'railgun') newMesh = createRailgunMesh(t.level);
            if (t.type === 'miner') newMesh = createNanominerMesh(t.level);

            // Fallback
            if (!newMesh) {
                // Basic
                const geom = new THREE.BoxGeometry(1.5, 3 + (t.level * 0.5), 1.5);
                const mat = new THREE.MeshLambertMaterial({ color: 0x0088ff });
                newMesh = new THREE.Mesh(geom, mat);
            }

            newMesh.position.copy(oldPos);
            // newMesh.rotation.copy(oldRot); // Let lookAt logic handle rotation

            newMesh.castShadow = true;
            newMesh.receiveShadow = true;
            scene.add(newMesh);
            t.mesh = newMesh;

            // UI Update
            refLevel.textContent = t.level;
            refDamage.textContent = Math.round(t.damage);
            refRange.textContent = t.range;
            refSpeed.textContent = (300 / t.maxCooldown).toFixed(1);

            if (t.level >= t.maxLevel) {
                btnUpgrade.textContent = "MAX LEVEL";
                btnUpgrade.style.background = "#555";
            }

            showError(`Upgraded to Level ${t.level}!`);
        });

        // Loop to update UI if selection changes (e.g. if we click another tower)
        function updateStatsUI() {
            if (selectedPlacedTower) {
                const t = selectedPlacedTower;
                refLevel.textContent = t.level || 1;

                // Calculate and display DPS
                const dps = (t.damage * 60 / t.maxCooldown).toFixed(1);
                document.getElementById('refDPS').textContent = dps;

                if (t.level >= t.maxLevel) {
                    btnUpgrade.textContent = "MAX LEVEL";
                    btnUpgrade.style.background = "#555";
                } else {
                    const cost = getUpgradeCost(t);
                    btnUpgrade.textContent = `UPGRADE ($${cost})`;
                    btnUpgrade.style.background = "#eab308";
                }
            }
        }
        setInterval(updateStatsUI, 200);

        // let ghostRing = ... (Removed duplicate)

        // Ensure selectionRing is here
        let selectionRing = new THREE.Mesh(new THREE.RingGeometry(1, 1.2, 32), new THREE.MeshBasicMaterial({ color: 0x4ade80, transparent: true, opacity: 0.5, side: THREE.DoubleSide }));
        selectionRing.rotation.x = -Math.PI / 2;
        selectionRing.visible = false;
        scene.add(selectionRing);

        function updateGhost(x, z) {
            if (!selectedTower) {
                ghostRing.visible = false;
                return;
            }
            ghostRing.visible = true;
            ghostRing.position.set(x, 0.2, z);

            // Scale based on tower range
            const typeData = TOWER_TYPES[selectedTower];
            const range = typeData ? typeData.range : 4;
            ghostRing.scale.set(range, range, 1);
        }


        function placeTower(x, z, groundY) {
            if (!selectedTower) return;
            const typeData = TOWER_TYPES[selectedTower];
            if (!typeData) return;

            // Snap to grid
            const snapX = Math.round(x / TILE_SIZE) * TILE_SIZE;
            const snapZ = Math.round(z / TILE_SIZE) * TILE_SIZE;

            // 1. Check existing
            if (towers.some(t => Math.abs(t.mesh.position.x - snapX) < 0.1 && Math.abs(t.mesh.position.z - snapZ) < 0.1)) {
                showError("BLOCKED: Occupied");
                return;
            }

            // 2. Check Path
            if (isPointOnPath(snapX, snapZ)) {
                showError("BLOCKED: Path");
                return;
            }

            // 3. Check Money
            const towerCost = typeData.cost;
            if (money < towerCost) {
                showError(`Need $${towerCost}!`);
                return;
            }

            // 4. Check High Ground Rule
            // define 'High Ground' as groundY > 0.1
            const isHighGround = groundY > 0.1;

            if (isHighGround && selectedTower !== 'sniper') {
                showError("Only Snipers allow High Ground!");
                return;
            }
            if (!isHighGround && selectedTower === 'sniper') {
                showError("Snipers MUST be on High Ground!");
                return;
            }

            // Spend Money
            spendMoney(towerCost);
            playSound('build'); // Placeholder sound

            let mesh;
            // Create Mesh based on type
            if (selectedTower === 'sniper') mesh = createSniperMesh();
            else if (selectedTower === 'scout') mesh = createScoutMesh();
            else if (selectedTower === 'pyro') mesh = createPyroMesh();
            else if (selectedTower === 'tesla') mesh = createTeslaMesh();
            else if (selectedTower === 'glacier') mesh = createGlacierMesh();
            else if (selectedTower === 'rocket') mesh = createRocketMesh();
            else if (selectedTower === 'amp') mesh = createAmplifierMesh();
            else if (selectedTower === 'railgun') mesh = createRailgunMesh();
            else if (selectedTower === 'miner') mesh = createNanominerMesh();
            else {
                // Basic fallback
                const geom = new THREE.BoxGeometry(1.5, 3, 1.5);
                const mat = new THREE.MeshLambertMaterial({ color: 0x0088ff });
                mesh = new THREE.Mesh(geom, mat);
            }

            // Adjust position
            // Most towers are group-based with y=0 origin, so groundY is correct
            // But basic fallback might need +1.5 if box is centered.
            // Our custom meshes are usually built upwards from 0.
            mesh.position.set(snapX, groundY, snapZ);

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Add to game logic
            const tower = {
                mesh: mesh,
                type: selectedTower,
                level: 1,
                maxLevel: 3,
                damage: typeData.damage,
                range: typeData.range,
                maxCooldown: typeData.cooldown,
                cooldown: 0,
                kills: 0,
                // Flags
                isSlow: typeData.isSlow,
                isSplash: typeData.isSplash,
                splashRadius: typeData.splashRadius,
                isSupport: typeData.isSupport,
                isPiercing: typeData.isPiercing,
                isEconomy: typeData.isEconomy,
                generation: typeData.generation
            };
            towers.push(tower);

            // Deselect after placement
            selectTower(null);
            if (window.ghostRing) window.ghostRing.visible = false;
        }



        // Raycaster for clicks
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Prevent context menu
        // Prevent context menu (Right Click) & Cancel Build
        window.addEventListener('contextmenu', e => {
            e.preventDefault();
            if (selectedTower) {
                selectedTower = null;
                ghostRing.visible = false;
                // Reset UI
                const buttons = [btnBasic, btnSniper, btnScout, btnPyro, btnTesla];
                buttons.forEach(b => b.style.borderColor = '#555');
            }
        });

        let isDragging = false;
        let mouseDownPos = new THREE.Vector2();

        window.addEventListener('pointerdown', (event) => {
            if (event.target.tagName === 'BUTTON') return;
            mouseDownPos.set(event.clientX, event.clientY);
            isDragging = false;
        });

        window.addEventListener('pointermove', (event) => {
            const dist = mouseDownPos.distanceTo(new THREE.Vector2(event.clientX, event.clientY));
            if (dist > 5) isDragging = true;

            // Ghost Ring Update
            if (selectedTower) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                // Raycast against ground for ghost
                const intersects = raycaster.intersectObjects([groundPlane, ...terrainObjects]);
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    // Snap
                    const snapX = Math.round(hit.point.x / TILE_SIZE) * TILE_SIZE;
                    const snapZ = Math.round(hit.point.z / TILE_SIZE) * TILE_SIZE;
                    let y = hit.point.y;
                    if (hit.object.userData.isTerrain) y = hit.object.userData.height;

                    updateGhost(snapX, snapZ);
                    ghostRing.position.y = y + 0.2;
                }
            }
        });

        window.addEventListener('pointerup', (event) => {
            if (isDragging) return;
            if (event.button !== 0) return;
            if (event.target.tagName === 'BUTTON') return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // 1. Check if clicked on EXISTING TOWER (Mesh check)
            // ONLY if NOT building (selectedTower is null)
            let hitTower = null;

            if (!selectedTower) {
                // Raycast against scene
                const allIntersects = raycaster.intersectObjects(scene.children, true);

                // Find first tower hit
                for (let i = 0; i < allIntersects.length; i++) {
                    const obj = allIntersects[i].object;

                    // Check if it's a hitbox
                    if (obj.userData.isHitbox) {
                        showDebug("HITBOX CLICKED");

                        // Try explicit link first
                        if (obj.userData.linkedTower) {
                            hitTower = obj.userData.linkedTower;
                            showDebug("TOWER FOUND (LINK)");
                            break;
                        }

                        // Traverse UP to find tower mesh (hitbox -> group -> might be tower)
                        let searchParent = obj.parent;
                        while (searchParent) {
                            const found = towers.find(t => t.mesh === searchParent);
                            if (found) {
                                hitTower = found;
                                showDebug("TOWER FOUND (PARENT SEARCH)");
                                break;
                            }
                            searchParent = searchParent.parent;
                            if (searchParent === scene) break;
                        }

                        if (hitTower) break;
                        showDebug("NO TOWER DATA - CHECK LINKAGE");
                        continue; // Skip non-hitbox fallback for this object
                    }

                    // Fallback: non-hitbox parts of tower
                    let current = obj;
                    while (current) {
                        const towerObj = towers.find(t => t.mesh === current);
                        if (towerObj) {
                            hitTower = towerObj;
                            showDebug("TOWER FOUND (MESH SEARCH)");
                            break;
                        }
                        current = current.parent;
                        if (current === scene) break;
                    }
                    if (hitTower) break;
                }
            }

            if (hitTower) {
                showDebug("OPENING UI...");
                showDebug("Step 1: Set selectedPlacedTower");
                // SELECT TOWER
                selectedPlacedTower = hitTower;
                showDebug("Step 2: Clear selectedTower");
                selectedTower = null; // Exit placement mode checks
                showDebug("Step 3: About to set panel style");

                // Show Stats - FORCED
                uiPanel.style.display = 'block';
                showDebug("Step 4: display=block done");
                uiPanel.style.visibility = 'visible';
                showDebug("Step 5: visibility=visible done");
                uiPanel.style.opacity = '1';
                showDebug("Step 6: opacity=1 done");

                showDebug("PANEL SHOULD BE VISIBLE NOW");

                uiName.textContent = hitTower.type.toUpperCase();
                uiRange.textContent = hitTower.range;
                uiSpeed.textContent = hitTower.maxCooldown * (1000 / 60) + "ms"; // approx
                uiDamage.textContent = hitTower.damage; // Now dynamic
                uiKills.textContent = hitTower.kills || 0;

                // Show Ring
                selectionRing.visible = true;
                selectionRing.position.copy(hitTower.mesh.position);
                selectionRing.position.y = hitTower.mesh.position.y - 1.5 + 0.1; // Base level
                if (hitTower.type === 'scout') selectionRing.position.y = hitTower.mesh.position.y + 0.1; // Scouts are at 0 origin

                selectionRing.scale.set(hitTower.range, hitTower.range, 1);

                return;
            }

            // 2. If no tower hit, try PLACE TOWER (if mode active)
            if (selectedTower) {
                const objectsToCheck = [groundPlane, ...terrainObjects];
                const intersects = raycaster.intersectObjects(objectsToCheck);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const point = hit.point;
                    let groundY = 0;
                    if (hit.object.userData.isTerrain) groundY = hit.object.userData.height;

                    placeTower(point.x, point.z, groundY);
                }
            } else {
                // Clicked empty space: Deselect
                selectedPlacedTower = null;
                // uiPanel.style.display = 'none'; // DEBUG: Commented out to see if this is checking
                selectionRing.visible = false;
            }
        });

        // Projectiles array
        // const projectiles = []; // Removed duplicate declaration

        // Projectiles
        function createProjectile(start, targetPos) {
            const geom = new THREE.SphereGeometry(0.2, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(start);
            scene.add(mesh);

            projectiles.push({
                mesh: mesh,
                target: targetPos, // Store the target position, not the enemy object
                speed: 1.0,
                active: true
            });
        }

        // document.getElementById('spawnBtn').addEventListener('click', spawnEnemy); // Replaced by Wave System

        // --- LOOP ---

        // Initialize ghostRing
        // let ghostRing = createRangeRing(1, 0xffffff); // REMOVED DUPLICATE

        // We need to add it to scene AFTER scene is created, which is done above.
        // Wait, scene is created in the previous block. We should make sure ghostRing is added.
        scene.add(ghostRing);
        ghostRing.visible = false;

        // ... (logic)                // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Stop game logic if game over
            if (isGameOver) {
                renderer.render(scene, camera);
                return;
            }

            // Run game logic multiple times based on speed
            for (let speedTick = 0; speedTick < gameSpeed; speedTick++) {

                // Enemy Logic
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (!enemy.active) continue;

                    // Cyber Gunner Logic (Stun Towers)
                    if (enemy.isGunner && speedTick === 0) { // Only check once per frame, not per speed tick to save perf
                        if (!enemy.lastShot) enemy.lastShot = 0;
                        if (Date.now() - enemy.lastShot > 3000) { // Shoot every 3 seconds
                            // Find a nearby tower
                            let targetTower = null;
                            let minTowerDist = 15;
                            for (const t of towers) {
                                if (t.stunned) continue; // Don't stun already stunned towers
                                const dist = enemy.mesh.position.distanceTo(t.mesh.position);
                                if (dist < minTowerDist) {
                                    minTowerDist = dist;
                                    targetTower = t;
                                }
                            }

                            if (targetTower) {
                                // Shoot!
                                enemy.lastShot = Date.now();
                                targetTower.stunned = true;
                                targetTower.stunTimer = 180; // Stun for ~3 seconds (at 60fps)

                                // Visual Beam
                                const lineGeom = new THREE.BufferGeometry().setFromPoints([
                                    enemy.mesh.position.clone().add(new THREE.Vector3(0, 1, 0)),
                                    targetTower.mesh.position.clone().add(new THREE.Vector3(0, 2, 0))
                                ]);
                                const lineMat = new THREE.LineBasicMaterial({ color: 0xff00ff });
                                const beam = new THREE.Line(lineGeom, lineMat);
                                scene.add(beam);
                                setTimeout(() => scene.remove(beam), 200);

                                showError("âš ï¸ TOWER HACKED! âš ï¸");
                            }
                        }
                    }

                    // Regeneration mutation
                    if (enemy.regenRate && enemy.hp < enemy.maxHp) {
                        enemy.hp = Math.min(enemy.maxHp, enemy.hp + enemy.regenRate / 60); // Per frame
                    }
                    // Move towards next node
                    const target = pathNodes[enemy.nodeIndex + 1];
                    if (!target) {
                        enemy.active = false;
                        scene.remove(enemy.mesh);
                        enemies.splice(i, 1);
                        continue;
                    }

                    const dir = new THREE.Vector3().subVectors(target, enemy.mesh.position).normalize();
                    dir.y = 0; // Keep horizontal movement only
                    const dist = enemy.mesh.position.distanceTo(new THREE.Vector3(target.x, enemy.mesh.position.y, target.z));

                    if (dist < 0.2) {
                        enemy.nodeIndex++;
                        if (enemy.nodeIndex >= pathNodes.length - 1) {
                            // Reached end - enemy escapes (game over disabled)
                            enemy.active = false;
                            scene.remove(enemy.mesh);
                            enemies.splice(i, 1);
                            // gameOver();
                            continue;
                        }
                    } else {
                        let moveSpeed = enemy.speed;
                        if (enemy.slowTimer > 0) {
                            enemy.slowTimer--;
                            moveSpeed *= 0.5;
                            enemy.mesh.material.emissive.setHex(0x00ffff); // Blue glow
                        } else {
                            enemy.mesh.material.emissive.setHex(0x000000); // Off
                        }
                        enemy.mesh.position.add(dir.multiplyScalar(moveSpeed));
                    }

                    // Maintain flying height
                    if (enemy.isFlying) {
                        enemy.mesh.position.y = enemy.baseY;
                    }
                }

                // --- WAVE SYSTEM UPDATE ---
                if (waveState === 'SPAWNING') {
                    if (spawnTimer > 0) {
                        spawnTimer--;
                    } else {
                        spawnEnemy();
                        enemiesToSpawn--;
                        spawnTimer = TIME_BETWEEN_SPAWNS;

                        if (enemiesToSpawn <= 0) {
                            waveState = 'ACTIVE';
                        }
                    }
                } else if (waveState === 'ACTIVE') {
                    // Check if all enemies dead
                    if (enemies.length === 0) {
                        waveState = 'COOLDOWN';
                        waveCooldown = TIME_BETWEEN_WAVES;

                        // Wave completion bonus
                        const waveBonus = 50 + (wave * 10);
                        addMoney(waveBonus);
                        showError(`Wave Cleared! +$${waveBonus} Bonus!`);
                    }
                } else if (waveState === 'COOLDOWN') {
                    if (waveCooldown > 0) {
                        waveCooldown--;
                    } else {
                        // NEXT WAVE
                        wave++;
                        startWave();
                    }
                }

                // Tower Logic (Shooting)
                towers.forEach(t => {
                    // Handle Stun
                    if (t.stunned) {
                        t.stunTimer--;
                        // Visual indicator for stun
                        if (!t.stunIndicator) {
                            const ring = new THREE.Mesh(
                                new THREE.RingGeometry(1, 1.2, 8),
                                new THREE.MeshBasicMaterial({ color: 0xff00ff, side: THREE.DoubleSide })
                            );
                            ring.rotation.x = -Math.PI / 2;
                            ring.position.y = 3;
                            t.mesh.add(ring);
                            t.stunIndicator = ring;
                        }
                        t.stunIndicator.rotation.z += 0.1;

                        if (t.stunTimer <= 0) {
                            t.stunned = false;
                            if (t.stunIndicator) {
                                t.mesh.remove(t.stunIndicator);
                                t.stunIndicator = null;
                            }
                        }
                        return; // Skip shooting if stunned
                    }

                    // 1. Nanominer Logic (Economy)
                    if (t.isEconomy) {
                        if (t.cooldown > 0) t.cooldown--;
                        else {
                            addMoney(t.generation);
                            // Visual Floating Text (reuse error for now or add effect)
                            // playSound('coin'); 
                            showDebug("+$" + t.generation);
                            t.cooldown = t.maxCooldown;

                            // Visual pulse
                            const pulse = new THREE.Mesh(new THREE.RingGeometry(0.5, 1, 16), new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true }));
                            pulse.rotation.x = -Math.PI / 2;
                            pulse.position.copy(t.mesh.position).add(new THREE.Vector3(0, 0.5, 0));
                            scene.add(pulse);

                            // Animate pulse (quick hack)
                            let scale = 1;
                            const anim = setInterval(() => {
                                scale += 0.2;
                                pulse.scale.set(scale, scale, 1);
                                pulse.material.opacity -= 0.1;
                                if (pulse.material.opacity <= 0) {
                                    scene.remove(pulse);
                                    clearInterval(anim);
                                }
                            }, 50);
                        }
                        return;
                    }

                    // 2. Amplifier Logic (Buffs)
                    if (t.isSupport) {
                        // Buff nearby towers
                        // Only run check occasionally to save perf? Or every frame is fine for simple distance
                        // Actually, buffs should be persistent or applied on attack.
                        // Let's visual pulse every 2s
                        /*
                        if (t.cooldown > 0) t.cooldown--;
                        else {
                            t.cooldown = 120;
                            // Visual Pulse
                            const ring = createRangeRing(4, 0x9333ea);
                            ring.position.copy(t.mesh.position).add(new THREE.Vector3(0,0.5,0));
                            scene.add(ring);
                            setTimeout(()=>scene.remove(ring), 500);
                        }
                        */
                        // Passive buff logic implemented implicitly: 
                        // Towers check for nearby amps when calculating stats? 
                        // OR we iterate towers here.
                        // Implementation Plan: For now, let's skip complex dynamic buffs and just make it a visual pulse tower 
                        // that occasionally zaps enemies in range? No, user wants support.
                        // Simplest Support: Adds damage to nearby towers.
                        // We can do this by iterating other towers.
                        if (Date.now() % 60 === 0) { // Check every second
                            towers.forEach(other => {
                                if (other === t) return;
                                if (other.mesh.position.distanceTo(t.mesh.position) < 4) {
                                    if (!other.hasBuff) {
                                        other.damage *= 1.2; // 20% boost
                                        other.hasBuff = true;
                                        // constant visual beam?
                                    }
                                }
                            });
                        }
                        return;
                    }

                    if (t.cooldown > 0) t.cooldown--;
                    else {
                        // Find target
                        let target = null;
                        let minDist = t.range;

                        // Railgun needs line definition, but first we need a primary target to aim at
                        // Splash needs primary target

                        for (const e of enemies) {
                            // Flying check: Basic and Pyro cannot hit flying
                            if (e.isFlying && (t.type === 'basic' || t.type === 'pyro')) continue;
                            // Miner/Amp don't shoot (handled above)

                            const dist = t.mesh.position.distanceTo(e.mesh.position);
                            if (dist < minDist) {
                                minDist = dist;
                                target = e;
                            }
                        }

                        if (target) {
                            t.cooldown = t.maxCooldown;

                            // Look at Target (Y-axis only)
                            t.mesh.lookAt(target.mesh.position.x, t.mesh.position.y, target.mesh.position.z);

                            // PLAY SOUND
                            playSound(t.type);

                            // --- SHOOTING LOGIC BY TYPE ---

                            // 1. SPLASH (Rocket)
                            if (t.isSplash) {
                                createProjectile(t.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), target.mesh.position);
                                // Explosion Visual
                                setTimeout(() => {
                                    const bang = new THREE.Mesh(new THREE.SphereGeometry(t.splashRadius, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 }));
                                    bang.position.copy(target.mesh.position);
                                    scene.add(bang);
                                    setTimeout(() => scene.remove(bang), 200);

                                    // Deal Damage
                                    enemies.forEach(e => {
                                        if (e.active && e.mesh.position.distanceTo(target.mesh.position) <= t.splashRadius) {
                                            dealDamage(e, t.damage, t);
                                        }
                                    });
                                }, 200); // Delay for projectile travel approx
                            }
                            // 2. PIERCING (Railgun)
                            else if (t.isPiercing) {
                                // Draw Beam
                                const beamGeom = new THREE.BufferGeometry().setFromPoints([
                                    t.mesh.position.clone().add(new THREE.Vector3(0, 1.8, 0)),
                                    target.mesh.position.clone().sub(t.mesh.position).normalize().multiplyScalar(50).add(t.mesh.position)
                                ]);
                                const beam = new THREE.Line(beamGeom, new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 }));
                                scene.add(beam);
                                setTimeout(() => scene.remove(beam), 100);

                                // Raycast Logic
                                const origin = t.mesh.position.clone().add(new THREE.Vector3(0, 1.8, 0));
                                const direction = target.mesh.position.clone().sub(origin).normalize();
                                const ray = new THREE.Ray(origin, direction);

                                enemies.forEach(e => {
                                    if (!e.active) return;
                                    // Check if enemy is close to the ray
                                    const vec = new THREE.Vector3().subVectors(e.mesh.position, origin);
                                    const proj = vec.projectOnVector(direction);
                                    if (proj.dot(direction) < 0) return; // Behind tower

                                    const distSq = e.mesh.position.distanceToSquared(origin.clone().add(proj)); // Distance to line
                                    if (distSq < 1.0) { // Hit width
                                        dealDamage(e, t.damage, t);
                                    }
                                });
                            }
                            // 3. SLOW (Glacier)
                            else if (t.isSlow) {
                                createProjectile(t.mesh.position.clone().add(new THREE.Vector3(0, 3, 0)), target.mesh.position);
                                setTimeout(() => {
                                    if (target.active) {
                                        dealDamage(target, t.damage, t);
                                        target.slowTimer = 120; // 2s
                                        // Visual Freeze
                                        /* 
                                        const ice = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({color:0x00ffff, wireframe:true}));
                                        ice.position.copy(target.mesh.position);
                                        scene.add(ice);
                                        setTimeout(()=>scene.remove(ice), 500); 
                                        */
                                    }
                                }, 100);
                            }
                            // 4. EXISTING TYPES
                            else {
                                // Visuals
                                if (t.type === 'sniper') {
                                    const lg = new THREE.BufferGeometry().setFromPoints([t.mesh.position.clone().add(new THREE.Vector3(0, 3, 0)), target.mesh.position]);
                                    const l = new THREE.Line(lg, new THREE.LineBasicMaterial({ color: 0xffaa00 }));
                                    scene.add(l);
                                    setTimeout(() => scene.remove(l), 50);
                                    dealDamage(target, t.damage, t); // Sniper deals damage instantly
                                } else if (t.type === 'pyro') {
                                    // continuous beam? line for now
                                    const lg = new THREE.BufferGeometry().setFromPoints([t.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), target.mesh.position]);
                                    const l = new THREE.Line(lg, new THREE.LineBasicMaterial({ color: 0xff4400 }));
                                    scene.add(l);
                                    setTimeout(() => scene.remove(l), 40);
                                    dealDamage(target, t.damage, t); // Pyro deals damage instantly
                                } else if (t.type === 'tesla') {
                                    // ... Chain Lightning (Simplified for this block)
                                    // Deal primary
                                    dealDamage(target, t.damage, t);
                                    // Chain
                                    let chainCount = 0;
                                    const limit = 2 + t.level;
                                    enemies.forEach(e => {
                                        if (chainCount >= limit) return;
                                        if (e !== target && e.active && e.mesh.position.distanceTo(target.mesh.position) < 8) {
                                            dealDamage(e, t.damage * 0.5, t);
                                            // Draw bolt
                                            // ...
                                            chainCount++;
                                        }
                                    });
                                } else {
                                    // Basic / Scout -> Projectile
                                    createProjectile(t.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), target.mesh.position);
                                    // Delay damage for travel? Or instant?
                                    // Let's do instant for responsiveness, visual catches up
                                    dealDamage(target, t.damage, t);
                                }
                            }
                        }
                    }
                });

                // Helper to apply damage (Hoisted)
                function dealDamage(enemy, amount, tower) {
                    if (!enemy.active) return;
                    let amt = amount || 0;
                    if (enemy.damageReduction) amt *= (1 - enemy.damageReduction);
                    if (enemy.isFrozen && amt > 5) amt *= 1.5; // Shatter bonus

                    enemy.hp -= amt;

                    // Hit reaction (flash white)
                    enemy.mesh.material.color.setHex(0xffffff);
                    setTimeout(() => {
                        if (enemy.active) {
                            const typeData = ENEMY_TYPES[enemy.type];
                            if (typeData) enemy.mesh.material.color.setHex(typeData.color);
                        }
                    }, 50);

                    if (enemy.hp <= 0) {
                        enemy.active = false;
                        scene.remove(enemy.mesh);
                        const idx = enemies.indexOf(enemy);
                        if (idx > -1) enemies.splice(idx, 1);

                        // Kill Credit
                        if (tower) {
                            tower.kills = (tower.kills || 0) + 1;
                            if (selectedPlacedTower === tower) {
                                document.getElementById('refKills').textContent = tower.kills;
                            }
                        }

                        // Money reward
                        let reward = 5 + Math.floor(wave * 0.5);
                        if (enemy.type && enemy.type.includes('boss')) reward *= 10;
                        if (enemy.type && enemy.type.includes('giant')) reward *= 3;
                        addMoney(Math.floor(reward));
                    }
                }

                // Update Counter
                document.getElementById('enemyCountDisplay').textContent = `Enemies: ${enemies.length}`;

                // Update Projectiles
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    if (!p.active) continue;

                    const dir = new THREE.Vector3().subVectors(p.target, p.mesh.position).normalize();
                    p.mesh.position.add(dir.multiplyScalar(2.0)); // Fast speed

                    if (p.mesh.position.distanceTo(p.target) < 1.0) {
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                    }
                }

            } // End speed loop

            composer.render();
        }

        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>