<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tower Defense</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
        }

        #enemyCountDisplay {
            position: absolute;
            top: 10px;
            right: 50%;
            transform: translateX(50%);
            color: #ff4444;
            font-family: sans-serif;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
        }

        #moneyDisplay {
            position: absolute;
            top: 40px;
            right: 50%;
            transform: translateX(50%);
            color: #4ade80;
            font-family: sans-serif;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        #statsPanel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 41, 59, 0.95);
            padding: 20px;
            border-radius: 8px;
            color: white;
            font-family: sans-serif;
            border: 2px solid #4ade80;
            width: 200px;
            z-index: 99999;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            display: none;
            /* Hidden by default */
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .stat-label {
            color: #94a3b8;
        }

        h2 {
            margin-top: 0;
            font-size: 18px;
            border-bottom: 1px solid #475569;
            padding-bottom: 8px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #ffffff;
            border: none;
            border-radius: 4px;
        }
    </style>
    <!-- Import Three.js module -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">
        <h1>3D Tower Defense</h1>
        <p>Left Click: Place Tower/Select | Right Click: Rotate | Scroll: Zoom</p>
    </div>

    <div id="enemyCountDisplay">Enemies: 0 | Wave: <span id="waveDisplay">1</span></div>
    <div id="moneyDisplay">$500</div>

    <div id="statsPanel">
        <h2 id="refName">Tower</h2>
        <div class="stat-row">
            <span class="stat-label">Range</span>
            <span id="refRange">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Damage</span>
            <span id="refDamage">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Cooldown</span>
            <span id="refSpeed">0ms</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Total Kills</span>
            <span id="refKills">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Level</span>
            <span id="refLevel">1</span>
        </div>
        <button id="btnUpgrade"
            style="width: 100%; margin-top: 10px; background: #eab308; color: black; font-weight: bold; cursor: pointer;">UPGRADE</button>
        <button id="btnCloseStats"
            style="width: 100%; margin-top: 10px; font-size: 12px; background: #ef4444; color: white;">Close</button>
    </div>

    <div id="controls">
        <button id="btnStartWave" style="background: #22c55e; color: white;">Start Game</button>
        <div style="width: 20px;"></div>
        <button id="btnBasic" style="border: 2px solid #3b82f6;">Basic<br><span
                style="font-size:10px;color:#4ade80;">$100</span></button>
        <button id="btnSniper" style="border: 2px solid #555;">Sniper<br><span
                style="font-size:10px;color:#4ade80;">$250</span></button>
        <button id="btnScout" style="border: 2px solid #555;">Scout<br><span
                style="font-size:10px;color:#4ade80;">$150</span></button>
        <button id="btnPyro" style="border: 2px solid #555; color: #f97316;">Pyro<br><span
                style="font-size:10px;color:#4ade80;">$200</span></button>
        <button id="btnTesla" style="border: 2px solid #555; color: #0ea5e9;">Tesla<br><span
                style="font-size:10px;color:#4ade80;">$300</span></button>
        <div style="width: 20px;"></div>
        <button id="btnMusic" style="border: 2px solid #888;">ðŸŽµ Music</button>
    </div>

    <!-- Background Music (Hidden) -->
    <div id="musicContainer" style="display:none;"></div>
    <script>
        // Simple YouTube Player Embed Logic
        // We inject the iframe when button is clicked to bypass some autoplay restrictions cleanly
        const btnMusic = document.getElementById('btnMusic');
        let musicPlaying = false;

        btnMusic.addEventListener('click', () => {
            const container = document.getElementById('musicContainer');
            if (!musicPlaying) {
                container.innerHTML = '<iframe width="1" height="1" src="https://www.youtube.com/embed/vq2AfGYwbE4?autoplay=1&loop=1&playlist=vq2AfGYwbE4" frameborder="0" allow="autoplay"></iframe>';
                musicPlaying = true;
                btnMusic.style.borderColor = '#4ade80'; // Green
                btnMusic.textContent = "ðŸ”Š Music On";
            } else {
                container.innerHTML = '';
                musicPlaying = false;
                btnMusic.style.borderColor = '#888';
                btnMusic.textContent = "ðŸŽµ Music Off";
            }
        });

        // --- SOUND FX ENGINE (Web Audio API) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        // Resume audio context on first user interaction
        window.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }, { once: true });

        function playSound(type) {
            if (audioCtx.state === 'suspended') return;

            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'sniper') {
                // BIG BANG
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);

                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

                osc.start(now);
                osc.stop(now + 0.4);

            } else if (type === 'pyro') {
                // HISS / WHITE NOISE (Simulated with erratic saw)
                // Real noise requires buffer, let's try erratic saw for "fire"
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.1);

                // Quick envelope
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.2);

                osc.start(now);
                osc.stop(now + 0.2);

            } else if (type === 'tesla') {
                // ZAP (High pitch slide)
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.1);

                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

                osc.start(now);
                osc.stop(now + 0.1);

            } else {
                // BASIC PEW
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);

                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

                osc.start(now);
                osc.stop(now + 0.1);
            }
        }
    </script>

    <!-- INLINE SCRIPT TO AVOID CORS ISSUES ON LOCAL FILESYSTEM -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Helper for Range Ring
        function createRangeRing(radius, color) {
            const geometry = new THREE.RingGeometry(radius - 0.2, radius, 64);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.y = 0.1; // Just above ground/road
            return mesh;
        }

        let ghostRing = createRangeRing(1, 0xffffff);

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505); // Darker background for bloom
        scene.fog = new THREE.Fog(0x050505, 20, 60);

        // Isometric view
        const aspect = window.innerWidth / window.innerHeight;
        const d = 60; // Zoom out for larger map
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20);
        camera.lookAt(scene.position);

        // --- REALISTIC RENDERER SETUP ---
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows

        // Tone Mapping & Color Space
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        document.body.appendChild(renderer.domElement);

        // --- POST-PROCESSING ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Bloom: Threshold (0-1), Strength, Radius
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.6; // Only VERY bright things glow
        bloomPass.strength = 0.8;  // Intensity
        bloomPass.radius = 0.5;    // Spread
        composer.addPass(bloomPass);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.maxPolarAngle = Math.PI / 2; // Prevent going under the map

        // Remap controls to standard RTS style
        controls.mouseButtons = {
            LEFT: THREE.MOUSE.PAN,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.ROTATE
        };


        // --- ADVANCED LIGHTING ---
        // 1. Hemisphere Light (Sky/Ground Ambient)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        // 2. Main Sun Directional Light
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); // Higher intensity for tone mapping
        dirLight.position.set(20, 40, 10);
        dirLight.castShadow = true;
        // Shadow properties
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -40;
        dirLight.shadow.camera.right = 40;
        dirLight.shadow.camera.top = 40;
        dirLight.shadow.camera.bottom = -40;
        dirLight.shadow.bias = -0.0005; // Fix shadow acne
        scene.add(dirLight);

        // --- GAME OBJECTS ---
        const TILE_SIZE = 2;
        const MAP_SIZE = 60;
        // Expanded path (5x larger and longer)
        const pathNodes = [
            new THREE.Vector3(-40, 0, -40),
            new THREE.Vector3(-40, 0, 20),
            new THREE.Vector3(-10, 0, 20),
            new THREE.Vector3(-10, 0, -20),
            new THREE.Vector3(20, 0, -20),
            new THREE.Vector3(20, 0, 20),
            new THREE.Vector3(50, 0, 20),
            new THREE.Vector3(50, 0, -50)
        ];

        // Large Ground Plane
        const planeGeom = new THREE.PlaneGeometry(500, 500);
        const planeMat = new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.8 });
        const groundPlane = new THREE.Mesh(planeGeom, planeMat);
        groundPlane.rotation.x = -Math.PI / 2;
        groundPlane.receiveShadow = true;
        scene.add(groundPlane);

        // Function to create road segments
        function createRoad() {
            const roadMat = new THREE.MeshStandardMaterial({
                color: 0x334155,
                roughness: 0.9,
                polygonOffset: true,
                polygonOffsetFactor: -1 // Draw on top of ground
            });

            for (let i = 0; i < pathNodes.length - 1; i++) {
                const start = pathNodes[i];
                const end = pathNodes[i + 1];

                const vec = new THREE.Vector3().subVectors(end, start);
                const length = vec.length();
                const angle = Math.atan2(vec.z, vec.x);

                // Segment mesh (+ extra length to cover corners)
                const geometry = new THREE.PlaneGeometry(length + (TILE_SIZE / 2), TILE_SIZE * 0.8);
                const mesh = new THREE.Mesh(geometry, roadMat);

                // Position at midpoint
                const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                mesh.position.copy(mid);
                mesh.position.y = 0.02; // Slightly above ground
                mesh.rotation.x = -Math.PI / 2;
                mesh.rotation.z = -angle;

                mesh.receiveShadow = true;
                scene.add(mesh);

                // Add rounded corners at nodes? maybe later. Simple rects for now.
            }
        }
        createRoad();


        const towers = [];
        const enemies = [];
        const projectiles = []; // Removed duplicate declaration

        // Tower selection state
        let selectedPlacedTower = null; // Existing tower that is selected for viewing stats

        // --- MONEY SYSTEM ---
        let money = 500; // Starting money
        const TOWER_COSTS = {
            basic: 100,
            sniper: 250,
            scout: 150,
            pyro: 200,
            tesla: 300
        };
        const UPGRADE_COST_BASE = 100; // Cost increases per level

        function getUpgradeCost(tower) {
            return UPGRADE_COST_BASE * tower.level;
        }

        function addMoney(amount) {
            money += amount;
            updateMoneyDisplay();
        }

        function spendMoney(amount) {
            if (money >= amount) {
                money -= amount;
                updateMoneyDisplay();
                return true;
            }
            return false;
        }

        function updateMoneyDisplay() {
            const display = document.getElementById('moneyDisplay');
            if (display) display.textContent = `$${money}`;
        }

        // --- WAVE SYSTEM VARIABLES ---
        let wave = 1;
        let waveState = 'IDLE'; // IDLE, SPAWNING, ACTIVE, COOLDOWN
        let enemiesToSpawn = 0;
        let spawnTimer = 0;
        let waveCooldown = 0;
        const TIME_BETWEEN_SPAWNS = 40; // ~0.7s
        const TIME_BETWEEN_WAVES = 300; // ~5s

        // --- ENEMY TYPES ---
        const ENEMY_TYPES = {
            normal: { name: 'Normal', hpMult: 1.0, speedMult: 1.0, size: 0.6, color: 0xff4444 },
            speedster: { name: 'Speedster', hpMult: 0.6, speedMult: 2.0, size: 0.4, color: 0x00ff00 },
            giant: { name: 'Giant', hpMult: 3.0, speedMult: 0.5, size: 1.2, color: 0x8b4513 },
            boss: { name: 'BOSS', hpMult: 15.0, speedMult: 0.3, size: 2.0, color: 0xff00ff },
            // Molten variants (Wave 25+)
            molten_normal: { name: 'Molten', hpMult: 2.0, speedMult: 1.2, size: 0.7, color: 0xff6600, isMolten: true },
            molten_speedster: { name: 'Molten Speedster', hpMult: 1.2, speedMult: 2.5, size: 0.5, color: 0xff9900, isMolten: true },
            molten_giant: { name: 'Molten Giant', hpMult: 5.0, speedMult: 0.6, size: 1.5, color: 0xcc3300, isMolten: true },
            molten_boss: { name: 'INFERNO BOSS', hpMult: 25.0, speedMult: 0.4, size: 2.5, color: 0xff0000, isMolten: true },
            // Frozen variants (Wave 50+)
            frozen_normal: { name: 'Frozen', hpMult: 3.0, speedMult: 1.0, size: 0.8, color: 0x88ddff, isFrozen: true },
            frozen_speedster: { name: 'Frozen Speedster', hpMult: 2.0, speedMult: 2.2, size: 0.6, color: 0x66ccff, isFrozen: true },
            frozen_giant: { name: 'Frozen Giant', hpMult: 8.0, speedMult: 0.5, size: 1.8, color: 0x4488cc, isFrozen: true },
            frozen_boss: { name: 'BLIZZARD LORD', hpMult: 40.0, speedMult: 0.35, size: 3.0, color: 0x00aaff, isFrozen: true },
            // Void variants (Wave 75+)
            void_normal: { name: 'Void', hpMult: 4.0, speedMult: 1.1, size: 0.9, color: 0x6600cc, isVoid: true },
            void_speedster: { name: 'Void Speedster', hpMult: 3.0, speedMult: 2.5, size: 0.7, color: 0x9933ff, isVoid: true },
            void_giant: { name: 'Void Giant', hpMult: 12.0, speedMult: 0.55, size: 2.0, color: 0x4400aa, isVoid: true },
            void_boss: { name: 'VOID EMPEROR', hpMult: 60.0, speedMult: 0.4, size: 3.5, color: 0x8800ff, isVoid: true },
            // Heavenly variants (Wave 100+)
            heavenly_normal: { name: 'Celestial', hpMult: 5.0, speedMult: 1.2, size: 1.0, color: 0xffdd88, isHeavenly: true },
            heavenly_speedster: { name: 'Seraph', hpMult: 4.0, speedMult: 2.8, size: 0.8, color: 0xffee99, isHeavenly: true },
            heavenly_giant: { name: 'Archangel', hpMult: 15.0, speedMult: 0.6, size: 2.2, color: 0xffffff, isHeavenly: true },
            heavenly_boss: { name: 'DIVINE TITAN', hpMult: 80.0, speedMult: 0.45, size: 4.0, color: 0xffffaa, isHeavenly: true }
        };

        let isLavaRealm = false; // Tracks if we've entered lava realm
        let isIceRealm = false; // Tracks if we've entered ice realm
        let isVoidRealm = false; // Tracks if we've entered void realm
        let isHeavenlyRealm = false; // Tracks if we've entered heavenly realm

        // Store biome objects for cleanup
        let biomeObjects = [];

        // --- MUTATIONS ---
        const MUTATIONS = {
            none: { name: '', effect: null },
            loaded: { name: 'Loaded', damageReduction: 0.5, color: 0x808080 }, // 50% damage reduction
            nimble: { name: 'Nimble', speedMult: 2.0, color: 0x00ffff },
            regen: { name: 'Regen', regenRate: 5, color: 0x00ff00 }, // HP per second
            flying: { name: 'Flying', isFlying: true, color: 0xffff00, height: 3.0 }
        };

        function spawnEnemy(typeOverride, mutationOverride) {
            // Determine enemy type
            let type = typeOverride || 'normal';

            // Random type selection if not overridden
            if (!typeOverride) {
                const roll = Math.random();
                if (roll < 0.15) type = 'speedster';
                else if (roll < 0.25) type = 'giant';

                // Use realm variants based on wave
                if (wave >= 100) {
                    type = 'heavenly_' + type;
                } else if (wave >= 75) {
                    type = 'void_' + type;
                } else if (wave >= 50) {
                    type = 'frozen_' + type;
                } else if (wave >= 25) {
                    type = 'molten_' + type;
                }
            }

            const typeData = ENEMY_TYPES[type];

            // Determine mutation (chance increases with wave)
            let mutation = mutationOverride || 'none';
            if (!mutationOverride && wave >= 3) {
                const mutationChance = Math.min(0.4, 0.05 * wave);
                if (Math.random() < mutationChance) {
                    const mutations = ['loaded', 'nimble', 'regen'];
                    if (wave >= 5) mutations.push('flying');
                    mutation = mutations[Math.floor(Math.random() * mutations.length)];
                }
            }
            const mutData = MUTATIONS[mutation];

            // Create mesh
            const geom = new THREE.SphereGeometry(typeData.size, 16, 16);

            // Color based on type, tinted by mutation
            let baseColor = new THREE.Color(typeData.color);
            if (mutation !== 'none') {
                baseColor.lerp(new THREE.Color(mutData.color), 0.4);
            }

            const mat = new THREE.MeshLambertMaterial({ color: baseColor });
            const mesh = new THREE.Mesh(geom, mat);

            const start = pathNodes[0];
            mesh.position.copy(start);
            mesh.position.y = typeData.size + (mutData.isFlying ? mutData.height : 0);

            // Add visual indicators for mutations
            if (mutation === 'flying') {
                // Add wings
                const wingMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                const wingL = new THREE.Mesh(new THREE.PlaneGeometry(typeData.size * 1.5, typeData.size * 0.8), wingMat);
                wingL.position.set(-typeData.size * 0.8, 0, 0);
                wingL.rotation.y = Math.PI / 4;
                mesh.add(wingL);
                const wingR = new THREE.Mesh(new THREE.PlaneGeometry(typeData.size * 1.5, typeData.size * 0.8), wingMat);
                wingR.position.set(typeData.size * 0.8, 0, 0);
                wingR.rotation.y = -Math.PI / 4;
                mesh.add(wingR);
            }

            if (mutation === 'loaded') {
                // Add armor plates
                const armorMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                const armor = new THREE.Mesh(new THREE.BoxGeometry(typeData.size * 1.2, typeData.size * 0.3, typeData.size * 1.2), armorMat);
                armor.position.set(0, typeData.size * 0.5, 0);
                mesh.add(armor);
            }

            if (mutation === 'regen') {
                // Add green glow
                const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3 });
                const glow = new THREE.Mesh(new THREE.SphereGeometry(typeData.size * 1.3, 8, 8), glowMat);
                mesh.add(glow);
            }

            // Molten enemy effects
            if (typeData.isMolten) {
                // Fire glow
                const fireMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.4 });
                const fireGlow = new THREE.Mesh(new THREE.SphereGeometry(typeData.size * 1.2, 8, 8), fireMat);
                mesh.add(fireGlow);

                // Point light
                const fireLight = new THREE.PointLight(0xff4400, 1, typeData.size * 4);
                mesh.add(fireLight);
            }

            // Frozen enemy effects
            if (typeData.isFrozen) {
                // Ice glow
                const iceMat = new THREE.MeshBasicMaterial({ color: 0x88ddff, transparent: true, opacity: 0.3 });
                const iceGlow = new THREE.Mesh(new THREE.SphereGeometry(typeData.size * 1.2, 8, 8), iceMat);
                mesh.add(iceGlow);

                // Ice crystals
                const crystalMat = new THREE.MeshBasicMaterial({ color: 0xaaeeff, transparent: true, opacity: 0.7 });
                for (let i = 0; i < 4; i++) {
                    const crystal = new THREE.Mesh(new THREE.ConeGeometry(typeData.size * 0.15, typeData.size * 0.4, 4), crystalMat);
                    crystal.position.set(
                        Math.cos(i * Math.PI / 2) * typeData.size * 0.6,
                        typeData.size * 0.3,
                        Math.sin(i * Math.PI / 2) * typeData.size * 0.6
                    );
                    mesh.add(crystal);
                }

                // Cold light
                const iceLight = new THREE.PointLight(0x88ddff, 0.8, typeData.size * 4);
                mesh.add(iceLight);
            }

            // Void enemy effects
            if (typeData.isVoid) {
                // Void glow (dark purple)
                const voidMat = new THREE.MeshBasicMaterial({ color: 0x6600cc, transparent: true, opacity: 0.5 });
                const voidGlow = new THREE.Mesh(new THREE.SphereGeometry(typeData.size * 1.3, 8, 8), voidMat);
                mesh.add(voidGlow);

                // Floating dark particles (rings)
                for (let i = 0; i < 3; i++) {
                    const ringMat = new THREE.MeshBasicMaterial({ color: 0x9933ff, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                    const ring = new THREE.Mesh(new THREE.RingGeometry(typeData.size * (0.8 + i * 0.3), typeData.size * (0.9 + i * 0.3), 8), ringMat);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = i * 0.3 - 0.2;
                    mesh.add(ring);
                }

                // Void light (dark purple glow)
                const voidLight = new THREE.PointLight(0x6600cc, 1, typeData.size * 5);
                mesh.add(voidLight);
            }

            // Heavenly enemy effects
            if (typeData.isHeavenly) {
                // Golden glow
                const goldenMat = new THREE.MeshBasicMaterial({ color: 0xffdd88, transparent: true, opacity: 0.4 });
                const goldenGlow = new THREE.Mesh(new THREE.SphereGeometry(typeData.size * 1.4, 8, 8), goldenMat);
                mesh.add(goldenGlow);

                // Halo
                const haloMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                const halo = new THREE.Mesh(new THREE.RingGeometry(typeData.size * 0.6, typeData.size * 0.8, 16), haloMat);
                halo.rotation.x = Math.PI / 2;
                halo.position.y = typeData.size + 0.3;
                mesh.add(halo);

                // Angel wings
                const wingMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
                const wingL = new THREE.Mesh(new THREE.PlaneGeometry(typeData.size * 1.2, typeData.size * 0.8), wingMat);
                wingL.position.set(-typeData.size * 0.8, typeData.size * 0.2, -0.2);
                wingL.rotation.y = Math.PI / 3;
                mesh.add(wingL);
                const wingR = new THREE.Mesh(new THREE.PlaneGeometry(typeData.size * 1.2, typeData.size * 0.8), wingMat);
                wingR.position.set(typeData.size * 0.8, typeData.size * 0.2, -0.2);
                wingR.rotation.y = -Math.PI / 3;
                mesh.add(wingR);

                // Divine light
                const divineLight = new THREE.PointLight(0xffffaa, 1.5, typeData.size * 6);
                mesh.add(divineLight);
            }

            scene.add(mesh);

            // Calculate HP (buffed base HP)
            const baseHp = 200 + (wave * 50); // Increased from 100 + wave*25
            const hp = Math.floor(baseHp * typeData.hpMult);

            // Calculate speed
            let speed = (0.06 + (wave * 0.003)) * typeData.speedMult;
            if (mutData.speedMult) speed *= mutData.speedMult;

            enemies.push({
                mesh: mesh,
                nodeIndex: 0,
                hp: hp,
                maxHp: hp,
                speed: speed,
                active: true,
                type: type,
                typeName: typeData.name,
                mutation: mutation,
                mutationName: mutData.name || '',
                damageReduction: mutData.damageReduction || 0,
                regenRate: mutData.regenRate || 0,
                isFlying: mutData.isFlying || false,
                baseY: typeData.size + (mutData.isFlying ? mutData.height : 0)
            });
        }

        function spawnBoss() {
            // Use realm boss based on wave
            let bossType = 'boss';
            let bossName = 'âš ï¸ BOSS';

            if (wave >= 100) {
                bossType = 'heavenly_boss';
                bossName = 'âœ¨ DIVINE TITAN';
            } else if (wave >= 75) {
                bossType = 'void_boss';
                bossName = 'ðŸ•³ï¸ VOID EMPEROR';
            } else if (wave >= 50) {
                bossType = 'frozen_boss';
                bossName = 'â„ï¸ BLIZZARD LORD';
            } else if (wave >= 25) {
                bossType = 'molten_boss';
                bossName = 'ðŸ”¥ INFERNO BOSS';
            }

            spawnEnemy(bossType, 'none');
            showError(`${bossName} INCOMING! âš ï¸`);
        }

        // Transform terrain to lava realm
        function transformToLavaRealm() {
            if (isLavaRealm) return;
            isLavaRealm = true;

            showError('ðŸŒ‹ THE REALM TRANSFORMS... ðŸŒ‹');

            // Change ground to lava colors
            groundPlane.material.color.setHex(0x1a0a00);
            groundPlane.material.emissive = new THREE.Color(0x330000);
            groundPlane.material.emissiveIntensity = 0.3;

            // Change scene background and fog
            scene.background = new THREE.Color(0x1a0500);
            scene.fog = new THREE.Fog(0x1a0500, 20, 80);

            // Change terrain objects to molten rock
            terrainObjects.forEach(obj => {
                obj.material = new THREE.MeshStandardMaterial({
                    color: 0x2a1a0a,
                    emissive: 0x441100,
                    emissiveIntensity: 0.5,
                    roughness: 0.8
                });
            });

            // Add lava pools (simple glowing circles on ground)
            for (let i = 0; i < 15; i++) {
                const poolGeom = new THREE.CircleGeometry(2 + Math.random() * 3, 16);
                const poolMat = new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    transparent: true,
                    opacity: 0.7
                });
                const pool = new THREE.Mesh(poolGeom, poolMat);
                pool.rotation.x = -Math.PI / 2;
                pool.position.set(
                    (Math.random() - 0.5) * 80,
                    0.05,
                    (Math.random() - 0.5) * 80
                );
                scene.add(pool);
                biomeObjects.push(pool);

                // Add glow light
                const lavaLight = new THREE.PointLight(0xff2200, 0.5, 8);
                lavaLight.position.copy(pool.position);
                lavaLight.position.y = 0.5;
                scene.add(lavaLight);
                biomeObjects.push(lavaLight);
            }
        }

        // Cleanup previous biome objects
        function cleanupBiomeObjects() {
            biomeObjects.forEach(obj => {
                scene.remove(obj);
            });
            biomeObjects = [];
        }

        // Transform terrain to ice realm
        function transformToIceRealm() {
            if (isIceRealm) return;
            isIceRealm = true;

            // Cleanup previous biome objects
            cleanupBiomeObjects();

            showError('â„ï¸ THE REALM FREEZES... â„ï¸');

            // Change ground to frozen colors
            groundPlane.material.color.setHex(0x1a2a3a);
            groundPlane.material.emissive = new THREE.Color(0x112233);
            groundPlane.material.emissiveIntensity = 0.2;

            // Change scene background and fog
            scene.background = new THREE.Color(0x0a1520);
            scene.fog = new THREE.Fog(0x0a1520, 15, 70);

            // Change terrain objects to frozen rock
            terrainObjects.forEach(obj => {
                obj.material = new THREE.MeshStandardMaterial({
                    color: 0x4488aa,
                    emissive: 0x224466,
                    emissiveIntensity: 0.3,
                    roughness: 0.3,
                    metalness: 0.5
                });
            });

            // Add ice patches (crystalline surfaces)
            for (let i = 0; i < 20; i++) {
                const patchGeom = new THREE.CircleGeometry(1.5 + Math.random() * 2.5, 6);
                const patchMat = new THREE.MeshBasicMaterial({
                    color: 0x88ddff,
                    transparent: true,
                    opacity: 0.5
                });
                const patch = new THREE.Mesh(patchGeom, patchMat);
                patch.rotation.x = -Math.PI / 2;
                patch.position.set(
                    (Math.random() - 0.5) * 80,
                    0.06,
                    (Math.random() - 0.5) * 80
                );
                scene.add(patch);

                // Add ice crystals on some patches
                if (Math.random() > 0.5) {
                    const crystalMat = new THREE.MeshBasicMaterial({ color: 0xaaeeff, transparent: true, opacity: 0.8 });
                    for (let j = 0; j < 3; j++) {
                        const crystal = new THREE.Mesh(new THREE.ConeGeometry(0.3, 1.5 + Math.random(), 4), crystalMat);
                        crystal.position.copy(patch.position);
                        crystal.position.x += (Math.random() - 0.5) * 2;
                        crystal.position.z += (Math.random() - 0.5) * 2;
                        crystal.position.y = 0.75;
                        scene.add(crystal);
                        biomeObjects.push(crystal);
                    }
                }

                // Add cold light
                const iceLight = new THREE.PointLight(0x88ddff, 0.3, 6);
                iceLight.position.copy(patch.position);
                iceLight.position.y = 0.5;
                scene.add(iceLight);
                biomeObjects.push(patch);
                biomeObjects.push(iceLight);
            }
        }

        // Transform terrain to void realm
        function transformToVoidRealm() {
            if (isVoidRealm) return;
            isVoidRealm = true;

            // Cleanup previous biome objects
            cleanupBiomeObjects();

            showError('ðŸ•³ï¸ THE VOID CONSUMES ALL... ðŸ•³ï¸');

            // Change ground to void colors (dark purple/black)
            groundPlane.material.color.setHex(0x0a0010);
            groundPlane.material.emissive = new THREE.Color(0x220044);
            groundPlane.material.emissiveIntensity = 0.4;

            // Change scene background and fog (very dark purple)
            scene.background = new THREE.Color(0x050008);
            scene.fog = new THREE.Fog(0x050008, 10, 60);

            // Change terrain objects to void corruption
            terrainObjects.forEach(obj => {
                obj.material = new THREE.MeshStandardMaterial({
                    color: 0x2a0044,
                    emissive: 0x440088,
                    emissiveIntensity: 0.6,
                    roughness: 0.5,
                    metalness: 0.7
                });
            });

            // Add void rifts (glowing purple cracks)
            for (let i = 0; i < 12; i++) {
                const riftGeom = new THREE.PlaneGeometry(1 + Math.random() * 3, 8 + Math.random() * 6);
                const riftMat = new THREE.MeshBasicMaterial({
                    color: 0x8800ff,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const rift = new THREE.Mesh(riftGeom, riftMat);
                rift.rotation.x = -Math.PI / 2;
                rift.rotation.z = Math.random() * Math.PI;
                rift.position.set(
                    (Math.random() - 0.5) * 80,
                    0.08,
                    (Math.random() - 0.5) * 80
                );
                scene.add(rift);
                biomeObjects.push(rift);

                // Add void energy pillar
                const pillarMat = new THREE.MeshBasicMaterial({ color: 0x6600cc, transparent: true, opacity: 0.4 });
                const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 1, 6, 6), pillarMat);
                pillar.position.copy(rift.position);
                pillar.position.y = 3;
                scene.add(pillar);
                biomeObjects.push(pillar);

                // Add void light
                const voidLight = new THREE.PointLight(0x8800ff, 0.6, 10);
                voidLight.position.copy(rift.position);
                voidLight.position.y = 1;
                scene.add(voidLight);
                biomeObjects.push(voidLight);
            }
        }

        // Transform terrain to heavenly realm
        function transformToHeavenlyRealm() {
            if (isHeavenlyRealm) return;
            isHeavenlyRealm = true;

            // Cleanup previous biome objects
            cleanupBiomeObjects();

            showError('âœ¨ THE HEAVENS OPEN... âœ¨');

            // Change ground to heavenly colors (bright gold/white)
            groundPlane.material.color.setHex(0xffeecc);
            groundPlane.material.emissive = new THREE.Color(0xffdd88);
            groundPlane.material.emissiveIntensity = 0.3;

            // Change scene background and fog (bright golden sky)
            scene.background = new THREE.Color(0xffeedd);
            scene.fog = new THREE.Fog(0xffeedd, 20, 100);

            // Change terrain objects to divine marble
            terrainObjects.forEach(obj => {
                obj.material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0xffdd88,
                    emissiveIntensity: 0.4,
                    roughness: 0.2,
                    metalness: 0.3
                });
            });

            // Add divine pillars and halos
            for (let i = 0; i < 15; i++) {
                // Golden halo rings on ground
                const haloGeom = new THREE.RingGeometry(2, 2.5, 16);
                const haloMat = new THREE.MeshBasicMaterial({
                    color: 0xffdd00,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const halo = new THREE.Mesh(haloGeom, haloMat);
                halo.rotation.x = -Math.PI / 2;
                halo.position.set(
                    (Math.random() - 0.5) * 80,
                    0.1,
                    (Math.random() - 0.5) * 80
                );
                scene.add(halo);
                biomeObjects.push(halo);

                // Light pillar rising from halo
                const pillarMat = new THREE.MeshBasicMaterial({ color: 0xffffcc, transparent: true, opacity: 0.3 });
                const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.8, 8, 8), pillarMat);
                pillar.position.copy(halo.position);
                pillar.position.y = 4;
                scene.add(pillar);
                biomeObjects.push(pillar);

                // Divine light
                const divineLight = new THREE.PointLight(0xffffaa, 0.8, 12);
                divineLight.position.copy(halo.position);
                divineLight.position.y = 2;
                scene.add(divineLight);
                biomeObjects.push(divineLight);
            }
        }

        const btnStartWave = document.getElementById('btnStartWave');
        const waveDisplay = document.getElementById('waveDisplay');

        btnStartWave.addEventListener('click', () => {
            if (waveState === 'IDLE') {
                startWave();
                btnStartWave.style.display = 'none'; // Hide after start, let it run
            }
        });

        function startWave() {
            waveState = 'SPAWNING';
            // Wave Logic: 5 + Wave Index enemies
            enemiesToSpawn = 5 + Math.floor(wave * 1.5);

            // Transform to lava realm at wave 25
            if (wave === 25) {
                transformToLavaRealm();
            }

            // Transform to ice realm at wave 50
            if (wave === 50) {
                transformToIceRealm();
            }

            // Transform to void realm at wave 75
            if (wave === 75) {
                transformToVoidRealm();
            }

            // Transform to heavenly realm at wave 100
            if (wave === 100) {
                transformToHeavenlyRealm();
            }

            // Boss wave every 10 waves
            if (wave % 10 === 0) {
                spawnBoss();
                showError(`âš ï¸ BOSS WAVE ${wave}! âš ï¸`);
            } else if (wave === 100) {
                showError(`âœ¨ WAVE 100: HEAVENLY REALM BEGINS! âœ¨`);
            } else if (wave === 75) {
                showError(`ðŸ•³ï¸ WAVE 75: VOID REALM BEGINS! ðŸ•³ï¸`);
            } else if (wave === 50) {
                showError(`â„ï¸ WAVE 50: ICE REALM BEGINS! â„ï¸`);
            } else if (wave === 25) {
                showError(`ðŸ”¥ WAVE 25: LAVA REALM BEGINS! ðŸ”¥`);
            } else {
                showError(`Wave ${wave} Started!`);
            }

            spawnTimer = 0;
            waveDisplay.textContent = wave;
        }

        // Create a small UI for errors
        const errorDiv = document.createElement('div');
        errorDiv.style.position = 'absolute';
        errorDiv.style.top = '50%';
        errorDiv.style.left = '50%';
        errorDiv.style.transform = 'translate(-50%, -50%)';
        errorDiv.style.color = '#ff4444';
        errorDiv.style.fontFamily = 'sans-serif';
        errorDiv.style.fontSize = '24px';
        errorDiv.style.fontWeight = 'bold';
        errorDiv.style.textShadow = '0 0 5px black';
        errorDiv.style.pointerEvents = 'none';
        errorDiv.style.opacity = '0';
        errorDiv.style.transition = 'opacity 0.5s';
        document.body.appendChild(errorDiv);

        function showError(msg) {
            errorDiv.textContent = msg;
            errorDiv.style.opacity = '1';
            setTimeout(() => errorDiv.style.opacity = '0', 1000);
        }

        // DEBUG TOAST (Bottom Right)
        const debugToast = document.createElement('div');
        debugToast.style.position = 'absolute';
        debugToast.style.bottom = '20px';
        debugToast.style.right = '20px';
        debugToast.style.padding = '10px 20px';
        debugToast.style.background = 'rgba(0,0,0,0.8)';
        debugToast.style.color = '#4ade80';
        debugToast.style.fontFamily = 'monospace';
        debugToast.style.fontSize = '16px';
        debugToast.style.borderRadius = '8px';
        debugToast.style.pointerEvents = 'none';
        debugToast.style.transition = 'opacity 0.3s';
        debugToast.style.opacity = '0';
        document.body.appendChild(debugToast);

        let debugMessages = [];
        function showDebug(msg) {
            debugMessages.push(msg);
            if (debugMessages.length > 10) debugMessages.shift(); // Keep last 10
            debugToast.innerHTML = debugMessages.join('<br>');
            debugToast.style.opacity = '1';
        }

        function isPointOnPath(x, z) {
            const point = new THREE.Vector3(x, 0, z);
            const threshold = 0.5; // Radius check (path is effectively 1 unit wide)

            for (let i = 0; i < pathNodes.length - 1; i++) {
                const a = pathNodes[i];
                const b = pathNodes[i + 1];

                // Line segment distance check
                const line = new THREE.Line3(a, b);
                const closest = new THREE.Vector3();
                line.closestPointToPoint(point, true, closest);

                if (closest.distanceTo(point) < threshold) {
                    return true;
                }
            }
            return false;
        }

        const terrainObjects = [];
        let selectedTower = 'basic'; // basic | sniper

        // Terrain Generation
        function generateTerrain() {
            const geom = new THREE.BoxGeometry(TILE_SIZE, 1, TILE_SIZE);
            const mat = new THREE.MeshStandardMaterial({ color: 0x64748b });

            let mountainsSpawned = 0;
            const targetMountains = 2;

            // Try to place mountains
            for (let attempt = 0; attempt < 1000; attempt++) {
                if (mountainsSpawned >= targetMountains) break;

                // Pick a center point
                let cx = Math.floor((Math.random() * 100 - 50) / TILE_SIZE) * TILE_SIZE;
                let cz = Math.floor((Math.random() * 100 - 50) / TILE_SIZE) * TILE_SIZE;

                const radius = 3; // 7x7 area for a wider, nicer hill
                const peakHeight = 10; // Peak height

                // Check constraints for the area
                let validLocation = true;

                // First pass: Validate area
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        const x = cx + (dx * TILE_SIZE);
                        const z = cz + (dz * TILE_SIZE);

                        // 1. Edge Constraint (Must be far from center)
                        if (Math.abs(x) < 35 && Math.abs(z) < 35) {
                            validLocation = false; break;
                        }

                        // 2. Map Bounds
                        if (Math.abs(x) > 65 || Math.abs(z) > 65) {
                            validLocation = false; break;
                        }

                        // 3. Path Safety
                        if (isPointOnPath(x, z)) {
                            validLocation = false; break;
                        }

                        // 4. Overlap Safety (Keep hills distinct for now)
                        if (terrainObjects.some(obj => Math.abs(obj.position.x - x) < 0.1 && Math.abs(obj.position.z - z) < 0.1)) {
                            validLocation = false; break;
                        }
                    }
                    if (!validLocation) break;
                }

                if (!validLocation) continue;

                // Second pass: Spawn blocks in stepped pyramid shape
                mountainsSpawned++;

                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        const x = cx + (dx * TILE_SIZE);
                        const z = cz + (dz * TILE_SIZE);

                        // Calculate height based on distance from center (Manhattan distance for pyramid, or random for noise)
                        // Let's use max(|dx|,|dz|) for concentric square rings (stepped pyramid)
                        const dist = Math.max(Math.abs(dx), Math.abs(dz));

                        // Peak is at dist 0. Height drops by 2 for each step out.
                        let height = peakHeight - (dist * 2);

                        // Optional: Add small random variation to make it look rugged, not perfect steps
                        // if (dist > 0) height += (Math.random() > 0.5 ? 1 : 0);

                        if (height <= 2) continue; // Too low, blend with ground

                        const mesh = new THREE.Mesh(geom, mat);
                        mesh.scale.set(1, height, 1);
                        mesh.position.set(x, height / 2, z);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData = { isTerrain: true, height: height };

                        scene.add(mesh);
                        terrainObjects.push(mesh);
                    }
                }
            }
            console.log("Spawned mountains:", mountainsSpawned);
        }
        generateTerrain(); // Call at startup

        // Tower Selection UI
        const btnBasic = document.getElementById('btnBasic');
        const btnSniper = document.getElementById('btnSniper');
        const btnScout = document.getElementById('btnScout');
        const btnPyro = document.getElementById('btnPyro');
        const btnTesla = document.getElementById('btnTesla');

        btnBasic.addEventListener('click', () => selectTower('basic'));
        btnSniper.addEventListener('click', () => selectTower('sniper'));
        btnScout.addEventListener('click', () => selectTower('scout'));
        btnPyro.addEventListener('click', () => selectTower('pyro'));
        btnTesla.addEventListener('click', () => selectTower('tesla'));

        function selectTower(type) {
            selectedTower = type;
            btnBasic.style.borderColor = type === 'basic' ? '#3b82f6' : '#555';
            btnSniper.style.borderColor = type === 'sniper' ? '#facc15' : '#555';
            btnScout.style.borderColor = type === 'scout' ? '#4ade80' : '#555';
            btnPyro.style.borderColor = type === 'pyro' ? '#f97316' : '#555';
            btnTesla.style.borderColor = type === 'tesla' ? '#0ea5e9' : '#555';
        }

        // Procedural Mesh Generators
        function createScoutMesh(level = 1) {
            const group = new THREE.Group();

            // Level-based colors
            // Lvl 1: Yellow/Blue casual
            // Lvl 2: Green tactical, helmet
            // Lvl 3: Gold elite, dual pistols, cape

            const skinColor = level === 3 ? 0xffd700 : (level === 2 ? 0x90ee90 : 0xfacc15);
            const shirtColor = level === 3 ? 0x1a1a2e : (level === 2 ? 0x22543d : 0x3b82f6);
            const pantsColor = level === 3 ? 0x2d2d44 : (level === 2 ? 0x1e3a2f : 0x1e293b);
            const gunColor = level === 3 ? 0xffd700 : (level === 2 ? 0x2f4f4f : 0x94a3b8);

            const matSkin = new THREE.MeshLambertMaterial({ color: skinColor });
            const matShirt = new THREE.MeshLambertMaterial({ color: shirtColor });
            const matPants = new THREE.MeshLambertMaterial({ color: pantsColor });
            const matGun = new THREE.MeshLambertMaterial({ color: gunColor });

            // Legs
            const LegL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.5), matPants);
            LegL.position.set(-0.3, 0.6, 0);
            LegL.castShadow = true;
            group.add(LegL);

            const LegR = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.5), matPants);
            LegR.position.set(0.3, 0.6, 0);
            LegR.castShadow = true;
            group.add(LegR);

            // Torso - bulkier at higher levels
            const torsoWidth = 1.2 + (level * 0.1);
            const torso = new THREE.Mesh(new THREE.BoxGeometry(torsoWidth, 1.2, 0.6), matShirt);
            torso.position.set(0, 1.8, 0);
            torso.castShadow = true;
            group.add(torso);

            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), matSkin);
            head.position.set(0, 2.8, 0);
            head.castShadow = true;
            group.add(head);

            // Helmet at level 2+
            if (level >= 2) {
                const helmet = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.4, 0.9), matShirt);
                helmet.position.set(0, 3.15, 0);
                group.add(helmet);

                // Visor
                const visorMat = new THREE.MeshBasicMaterial({ color: level === 3 ? 0xff4400 : 0x00ff00 });
                const visor = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.15, 0.1), visorMat);
                visor.position.set(0, 2.95, 0.41);
                group.add(visor);
            } else {
                // Cap at level 1
                const cap = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.2, 0.85), matShirt);
                cap.position.set(0, 3.25, 0);
                group.add(cap);
            }

            // Arms
            const ArmL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.0, 0.4), matShirt);
            ArmL.position.set(-0.8, 1.8, 0);
            group.add(ArmL);
            const HandL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), matSkin);
            HandL.position.set(-0.8, 1.1, 0);
            group.add(HandL);

            const ArmR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.0, 0.4), matShirt);
            ArmR.position.set(0.8, 1.8, 0.2);
            ArmR.rotation.x = -Math.PI / 2;
            group.add(ArmR);
            const HandR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), matSkin);
            HandR.position.set(0.8, 1.8, 0.9);
            group.add(HandR);

            // Pistol (Right hand)
            const gunMain = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.8), matGun);
            gunMain.position.set(0.8, 2.0, 1.2);
            group.add(gunMain);
            const gunHandle = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), matGun);
            gunHandle.position.set(0.8, 1.7, 0.9);
            group.add(gunHandle);

            // Dual pistols at level 3
            if (level === 3) {
                const gun2Main = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.8), matGun);
                gun2Main.position.set(-0.8, 1.3, 0.4);
                group.add(gun2Main);
            }

            // Cape at level 3
            if (level === 3) {
                const capeMat = new THREE.MeshLambertMaterial({ color: 0x8b0000, side: THREE.DoubleSide });
                const cape = new THREE.Mesh(new THREE.PlaneGeometry(1.0, 1.5), capeMat);
                cape.position.set(0, 1.5, -0.35);
                cape.rotation.x = 0.2;
                group.add(cape);
            }

            // Face
            const matBlack = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.05), matBlack);
            eyeL.position.set(-0.2, 2.9, 0.41);
            group.add(eyeL);
            const eyeR = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.05), matBlack);
            eyeR.position.set(0.2, 2.9, 0.41);
            group.add(eyeR);
            const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.05), matBlack);
            mouth.position.set(0, 2.7, 0.41);
            group.add(mouth);

            // Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.5, 1.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            hitbox.position.set(0, 1.75, 0);
            hitbox.userData = { isHitbox: true };
            group.add(hitbox);

            return group;
        }

        function createSniperMesh(level = 1) {
            const group = new THREE.Group();

            // Level-based colors
            // Lvl 1: Standard tactical grey
            // Lvl 2: Desert camo tan, larger scope
            // Lvl 3: Arctic white with gold trim, energy rifle

            const clothesDarkColor = level === 3 ? 0xf0f0f0 : (level === 2 ? 0x8b7355 : 0x334155);
            const clothesLightColor = level === 3 ? 0xffffff : (level === 2 ? 0xd2b48c : 0x64748b);
            const gunBodyColor = level === 3 ? 0xffd700 : (level === 2 ? 0x654321 : 0x94a3b8);
            const glassColor = level === 3 ? 0xff0000 : (level === 2 ? 0x00ff00 : 0xf59e0b);

            const matSkin = new THREE.MeshLambertMaterial({ color: 0xffdcb1 });
            const matClothesDark = new THREE.MeshLambertMaterial({ color: clothesDarkColor });
            const matClothesLight = new THREE.MeshLambertMaterial({ color: clothesLightColor });
            const matBlack = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const matGunBody = new THREE.MeshLambertMaterial({ color: gunBodyColor });
            const matGlass = new THREE.MeshLambertMaterial({ color: glassColor });

            // Legs
            const LegL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.6), matClothesDark);
            LegL.position.set(-0.4, 0.6, 0);
            LegL.castShadow = true;
            group.add(LegL);

            const LegR = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.6), matClothesDark);
            LegR.position.set(0.4, 0.6, 0);
            LegR.castShadow = true;
            group.add(LegR);

            // Torso
            const torso = new THREE.Mesh(new THREE.BoxGeometry(1.3, 1.2, 0.7), matClothesDark);
            torso.position.set(0, 1.8, 0);
            torso.castShadow = true;
            group.add(torso);

            // Armor vest at level 2+
            if (level >= 2) {
                const vestMat = new THREE.MeshLambertMaterial({ color: level === 3 ? 0xffd700 : 0x556b2f });
                const vest = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.8, 0.5), vestMat);
                vest.position.set(0, 1.9, 0.15);
                group.add(vest);
            }

            // Head
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), matSkin);
            head.position.set(0, 2.85, 0);
            head.castShadow = true;
            group.add(head);

            // Cap
            const cap = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.3, 1.0), matClothesDark);
            cap.position.set(0, 3.3, 0);
            group.add(cap);

            // Headphones
            const phoneL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, 0.4), matBlack);
            phoneL.position.set(-0.5, 2.85, 0);
            group.add(phoneL);
            const phoneR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, 0.4), matBlack);
            phoneR.position.set(0.5, 2.85, 0);
            group.add(phoneR);
            const phoneBand = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.1, 0.2), matBlack);
            phoneBand.position.set(0, 3.35, 0);
            group.add(phoneBand);

            // Sunglasses
            const glasses = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.25, 0.1), matGlass);
            glasses.position.set(0, 2.9, 0.46);
            group.add(glasses);

            // Arms
            const ArmL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.2, 0.4), matClothesLight);
            ArmL.position.set(-0.6, 2.0, 0.6);
            ArmL.rotation.x = -Math.PI / 2;
            ArmL.rotation.z = -0.2;
            group.add(ArmL);

            const ArmR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.2, 0.4), matClothesLight);
            ArmR.position.set(0.6, 2.0, 0.4);
            ArmR.rotation.x = -Math.PI / 2;
            ArmR.rotation.z = 0.2;
            group.add(ArmR);

            // --- RIFLE ---
            const rifleGroup = new THREE.Group();

            // Main Body - longer at higher levels
            const rifleLength = 1.5 + (level * 0.3);
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, rifleLength), matGunBody);
            body.position.set(0, 0, 0);
            rifleGroup.add(body);

            // Barrel
            const barrelLength = 2.5 + (level * 0.5);
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, barrelLength, 8), matBlack);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0.1, rifleLength / 2 + barrelLength / 2);
            rifleGroup.add(barrel);

            // Muzzle Brake
            const muzzle = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.4), matBlack);
            muzzle.position.set(0, 0.1, rifleLength / 2 + barrelLength + 0.2);
            rifleGroup.add(muzzle);

            // Scope - bigger at higher levels
            const scopeSize = 0.12 + (level * 0.03);
            const scopeLength = 0.8 + (level * 0.2);
            const scope = new THREE.Mesh(new THREE.CylinderGeometry(scopeSize, scopeSize + 0.03, scopeLength, 16), matBlack);
            scope.rotation.x = Math.PI / 2;
            scope.position.set(0, 0.4, 0.2);
            rifleGroup.add(scope);

            // Scope glow at level 3
            if (level === 3) {
                const scopeGlowMat = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000 });
                const scopeGlow = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), scopeGlowMat);
                scopeGlow.position.set(0, 0.4, 0.7);
                rifleGroup.add(scopeGlow);
            }

            // Stock
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.8), matBlack);
            stock.position.set(0, -0.1, -rifleLength / 2 - 0.4);
            rifleGroup.add(stock);

            // Position Rifle
            rifleGroup.position.set(0, 2.1, 0.5);
            group.add(rifleGroup);

            // Ghillie suit at level 3
            if (level === 3) {
                const ghillieMat = new THREE.MeshLambertMaterial({ color: 0x228b22, side: THREE.DoubleSide });
                for (let i = 0; i < 8; i++) {
                    const strand = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 0.6), ghillieMat);
                    strand.position.set(
                        (Math.random() - 0.5) * 1.2,
                        1.5 + Math.random() * 1.0,
                        -0.4
                    );
                    strand.rotation.y = Math.random() * Math.PI;
                    group.add(strand);
                }
            }

            // Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.5, 1.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            hitbox.position.set(0, 1.75, 0);
            hitbox.userData = { isHitbox: true };
            group.add(hitbox);

            return group;
        }

        function createPyroMesh(level = 1) {
            const group = new THREE.Group();

            // Level-based colors
            // Lvl 1: Dark red robe, orange fire
            // Lvl 2: Purple robe, blue fire, shoulder pads
            // Lvl 3: Black robe with gold trim, white-hot fire, floating runes

            const robeColor = level === 3 ? 0x1a1a2e : (level === 2 ? 0x4a1942 : 0x7c2d12);
            const fireColor = level === 3 ? 0xffffff : (level === 2 ? 0x3b82f6 : 0xff4400);
            const fireEmissive = level === 3 ? 0xffffaa : (level === 2 ? 0x60a5fa : 0xff5500);
            const trimColor = level === 3 ? 0xffd700 : (level === 2 ? 0xa855f7 : 0xf97316);

            const matRobe = new THREE.MeshStandardMaterial({ color: robeColor, roughness: 0.9 });
            const matTrim = new THREE.MeshStandardMaterial({ color: trimColor, roughness: 0.6, emissive: trimColor, emissiveIntensity: 0.3 * level });
            const matSkin = new THREE.MeshStandardMaterial({ color: 0xfca5a5, roughness: 0.8 });
            const matStaff = new THREE.MeshStandardMaterial({ color: level === 3 ? 0x8b5a2b : 0x451a03, roughness: 1.0 });
            const matFire = new THREE.MeshStandardMaterial({ color: fireColor, emissive: fireEmissive, emissiveIntensity: 2.0 + level, transparent: true, opacity: 0.9 });

            // Robe Body - taller at higher levels
            const robeHeight = 1.8 + (level * 0.2);
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.6, robeHeight, 8), matRobe);
            body.position.set(0, robeHeight / 2, 0);
            body.castShadow = true;
            group.add(body);

            // Trim at bottom of robe
            const trimRing = new THREE.Mesh(new THREE.TorusGeometry(0.55, 0.08, 8, 16), matTrim);
            trimRing.rotation.x = Math.PI / 2;
            trimRing.position.set(0, 0.1, 0);
            group.add(trimRing);

            // Head (Hooded)
            const hood = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), matRobe);
            hood.position.set(0, robeHeight + 0.3, 0);
            hood.castShadow = true;
            group.add(hood);

            const face = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), matSkin);
            face.position.set(0, robeHeight + 0.3, 0.15);
            group.add(face);

            // Shoulder pads at level 2+
            if (level >= 2) {
                const shoulderL = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), matTrim);
                shoulderL.position.set(-0.5, robeHeight - 0.2, 0);
                group.add(shoulderL);

                const shoulderR = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), matTrim);
                shoulderR.position.set(0.5, robeHeight - 0.2, 0);
                group.add(shoulderR);
            }

            // Staff - more ornate at higher levels
            const staffLength = 2.5 + (level * 0.3);
            const staffHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.07, staffLength), matStaff);
            staffHandle.position.set(0.6, staffLength / 2 + 0.3, 0.5);
            staffHandle.rotation.x = 0.2;
            group.add(staffHandle);

            // Orb on staff - bigger with level
            const orbSize = 0.25 + (level * 0.1);
            const orb = new THREE.Mesh(new THREE.SphereGeometry(orbSize, 16, 16), matFire);
            orb.position.set(0.6, staffLength + 0.5, 0.7);
            group.add(orb);

            // Multiple orbs at level 3
            if (level === 3) {
                const orb2 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), matFire);
                orb2.position.set(0.3, staffLength + 0.3, 0.5);
                group.add(orb2);

                const orb3 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), matFire);
                orb3.position.set(0.9, staffLength + 0.3, 0.5);
                group.add(orb3);
            }

            // Light from staff - brighter with level
            const light = new THREE.PointLight(fireEmissive, 2 + level, 5 + level * 2);
            light.position.set(0.6, staffLength + 0.5, 0.7);
            group.add(light);

            // Floating runes at level 3+
            if (level >= 3) {
                const runeScale = 1 + (level - 3) * 0.1; // Grows with level
                const runeGeom = new THREE.RingGeometry(0.8 * runeScale, 1.0 * runeScale, 6);
                const runeMat = new THREE.MeshBasicMaterial({ color: 0xffd700, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                const rune = new THREE.Mesh(runeGeom, runeMat);
                rune.rotation.x = Math.PI / 2;
                rune.position.set(0, 0.3, 0);
                group.add(rune);

                // Extra runes at level 5+
                if (level >= 5) {
                    const rune2 = rune.clone();
                    rune2.position.y = 0.6;
                    rune2.scale.set(0.8, 0.8, 0.8);
                    group.add(rune2);
                }
            }

            // Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.0, 1.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            hitbox.position.set(0, 1.5, 0);
            hitbox.userData = { isHitbox: true };
            group.add(hitbox);

            return group;
        }

        function createTeslaMesh(level = 1) {
            const group = new THREE.Group();

            // Materials
            // Lvl 3+ = Gold Plating
            const metalColor = level >= 3 ? 0xffd700 : 0x94a3b8;
            const coreColor = level >= 3 ? 0xa855f7 : 0x00ffff; // Purple vs Cyan core

            const matMetal = new THREE.MeshStandardMaterial({ color: metalColor, metalness: level >= 3 ? 1.0 : 0.9, roughness: 0.2 });
            const matCoil = new THREE.MeshStandardMaterial({ color: 0xb8c0ff, metalness: 0.8, roughness: 0.3 });
            const matEnergy = new THREE.MeshStandardMaterial({ color: coreColor, emissive: coreColor, emissiveIntensity: 2.0 + level });

            // Base platform
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.0, 0.5, 8), matMetal);
            base.position.set(0, 0.25, 0);
            base.castShadow = true;
            group.add(base);

            // Pillar
            const height = 1.5 + ((level - 1) * 0.5); // Taller per level
            const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, height, 8), matMetal);
            pillar.position.set(0, 0.25 + (height / 2), 0);
            group.add(pillar);

            // Coils (Rings)
            const ringCount = 2 + level; // 3, 4, 5 rings
            for (let i = 0; i < ringCount; i++) {
                const ring = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.08, 8, 16), matCoil);
                ring.rotation.x = Math.PI / 2;
                const yPos = 0.8 + (i * (height / ringCount));
                ring.position.set(0, yPos, 0);
                group.add(ring);
            }

            // Top Orb
            const orb = new THREE.Mesh(new THREE.SphereGeometry(0.5 + (level * 0.1), 16, 16), matEnergy);
            orb.position.set(0, 0.25 + height + 0.5, 0);
            group.add(orb);

            // Ambient glow
            const light = new THREE.PointLight(coreColor, 1.5 + level, 4 + level);
            light.position.set(0, 0.25 + height + 0.5, 0);
            group.add(light);

            // Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.5, 1.5), new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
            hitbox.position.set(0, 1.75, 0);
            hitbox.userData = { isHitbox: true };
            group.add(hitbox);

            return group;
        }

        // Stats UI Refs
        const uiPanel = document.getElementById('statsPanel');
        uiPanel.style.display = 'none'; // Start hidden
        const uiName = document.getElementById('refName');
        const uiRange = document.getElementById('refRange');
        const uiDamage = document.getElementById('refDamage');
        const uiSpeed = document.getElementById('refSpeed');
        const uiKills = document.getElementById('refKills');
        document.getElementById('btnCloseStats').onclick = () => {
            selectedPlacedTower = null;
            uiPanel.style.display = 'none';
            selectionRing.visible = false;
        };

        const btnUpgrade = document.getElementById('btnUpgrade');
        const refLevel = document.getElementById('refLevel');

        btnUpgrade.addEventListener('click', () => {
            if (!selectedPlacedTower) return;
            const t = selectedPlacedTower;

            // Safety check for level
            if (!t.level) t.level = 1;
            if (!t.maxLevel) t.maxLevel = 3;

            if (t.level >= t.maxLevel) {
                showError("Max Level Reached!");
                return;
            }

            // Check upgrade cost
            const upgradeCost = getUpgradeCost(t);
            if (money < upgradeCost) {
                showError(`Need $${upgradeCost} to upgrade!`);
                return;
            }

            // Spend money
            spendMoney(upgradeCost);

            // Upgrade Logic
            t.level++;
            t.damage *= 1.5; // 50% Damage boost
            t.range += 2;    // Slight range boost
            t.cooldown *= 0.9; // 10% Faster

            // Visual Update (Re-mesh)
            const oldPos = t.mesh.position.clone();
            const oldRot = t.mesh.rotation.clone();
            scene.remove(t.mesh);

            let newMesh;
            if (t.type === 'sniper') newMesh = createSniperMesh();
            if (t.type === 'pyro') newMesh = createPyroMesh(t.level);
            if (t.type === 'tesla') newMesh = createTeslaMesh(t.level);
            if (t.type === 'scout') newMesh = createScoutMesh();
            // Fallback
            if (!newMesh) {
                // Basic
                const geom = new THREE.BoxGeometry(1.5, 3 + (t.level * 0.5), 1.5);
                const mat = new THREE.MeshLambertMaterial({ color: 0x0088ff });
                newMesh = new THREE.Mesh(geom, mat);
            }

            newMesh.position.copy(oldPos);
            // newMesh.rotation.copy(oldRot); // Let lookAt logic handle rotation

            newMesh.castShadow = true;
            newMesh.receiveShadow = true;
            scene.add(newMesh);
            t.mesh = newMesh;

            // UI Update
            refLevel.textContent = t.level;
            refDamage.textContent = Math.round(t.damage);
            refRange.textContent = t.range;
            refSpeed.textContent = (300 / t.maxCooldown).toFixed(1);

            if (t.level >= t.maxLevel) {
                btnUpgrade.textContent = "MAX LEVEL";
                btnUpgrade.style.background = "#555";
            }

            showError(`Upgraded to Level ${t.level}!`);
        });

        // Loop to update UI if selection changes (e.g. if we click another tower)
        function updateStatsUI() {
            if (selectedPlacedTower) {
                const t = selectedPlacedTower;
                refLevel.textContent = t.level || 1;
                if (t.level >= t.maxLevel) {
                    btnUpgrade.textContent = "MAX LEVEL";
                    btnUpgrade.style.background = "#555";
                } else {
                    btnUpgrade.textContent = "UPGRADE";
                    btnUpgrade.style.background = "#eab308";
                }
            }
        }
        setInterval(updateStatsUI, 200);

        // let ghostRing = ... (Removed duplicate)

        // Ensure selectionRing is here
        let selectionRing = new THREE.Mesh(new THREE.RingGeometry(1, 1.2, 32), new THREE.MeshBasicMaterial({ color: 0x4ade80, transparent: true, opacity: 0.5, side: THREE.DoubleSide }));
        selectionRing.rotation.x = -Math.PI / 2;
        selectionRing.visible = false;
        scene.add(selectionRing);

        function updateGhost(x, z) {
            if (!selectedTower) {
                ghostRing.visible = false;
                return;
            }
            ghostRing.visible = true;
            ghostRing.position.set(x, 0.2, z);

            // Scale based on tower range
            let range = 8;
            if (selectedTower === 'sniper') range = 60; // Sync with real range
            if (selectedTower === 'scout') range = 10;
            if (selectedTower === 'pyro') range = 6;
            if (selectedTower === 'tesla') range = 15;

            // RingGeometry is static, so scale string
            // Base radius is ~1. So scale to range.
            ghostRing.scale.set(range, range, 1);
        }

        // --- UPDATED INPUT LOGIC ---
        // (Existing raycaster/listeners need to be slightly modified to trigger this)


        function placeTower(x, z, groundY) {
            // ... (keep existing placeTower)
            // Snap to grid
            const snapX = Math.round(x / TILE_SIZE) * TILE_SIZE;
            const snapZ = Math.round(z / TILE_SIZE) * TILE_SIZE;

            // 1. Check existing
            if (towers.some(t => Math.abs(t.mesh.position.x - snapX) < 0.1 && Math.abs(t.mesh.position.z - snapZ) < 0.1)) {
                showError("BLOCKED: Occupied");
                return;
            }

            // 2. Check Path
            if (isPointOnPath(snapX, snapZ)) {
                showError("BLOCKED: Path");
                return;
            }

            // 3. Check Money
            const towerCost = TOWER_COSTS[selectedTower] || 100;
            if (money < towerCost) {
                showError(`Need $${towerCost}!`);
                return;
            }

            // 4. Check High Ground Rule
            // define 'High Ground' as groundY > 0.1
            const isHighGround = groundY > 0.1;

            if (isHighGround && selectedTower !== 'sniper') {
                showError("Only Snipers allow High Ground!");
                return;
            }
            if (!isHighGround && selectedTower === 'sniper') {
                showError("Snipers MUST be on High Ground!");
                return;
            }

            let mesh;
            let range = 8;
            let cooldown = 30; // 0.5s at 60fps

            if (selectedTower === 'scout') {
                mesh = createScoutMesh();
                // Adjust position since group origin is 0,0,0
                mesh.position.set(snapX, groundY, snapZ);
                range = 10;
                cooldown = 15; // Fast fire
            } else if (selectedTower === 'sniper') {
                mesh = createSniperMesh();
                mesh.position.set(snapX, groundY, snapZ);
                range = 60; // Map-wide
                cooldown = 120;
            } else if (selectedTower === 'pyro') {
                mesh = createPyroMesh();
                mesh.position.set(snapX, groundY, snapZ);
                range = 6; // Very short range
                cooldown = 5; // Very fast tick
            } else if (selectedTower === 'tesla') {
                mesh = createTeslaMesh();
                mesh.position.set(snapX, groundY, snapZ);
                range = 15; // Medium range
                cooldown = 45;
            } else {
                // Basic
                const geom = new THREE.BoxGeometry(1.5, 3, 1.5);
                const mat = new THREE.MeshLambertMaterial({ color: 0x0088ff });
                mesh = new THREE.Mesh(geom, mat);
                mesh.position.set(snapX, groundY + 1.5, snapZ);
            }

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const entry = {
                mesh: mesh,
                type: selectedTower,
                range: range,
                damage: selectedTower === 'sniper' ? 50 : (selectedTower === 'scout' ? 10 : (selectedTower === 'pyro' ? 8 : (selectedTower === 'tesla' ? 25 : 20))),
                level: 1,
                maxLevel: 10,
                cooldown: 0,
                maxCooldown: cooldown,
                kills: 0
            };
            towers.push(entry);

            // Link Hitbox for Raycasting
            mesh.traverse(child => {
                if (child.userData.isHitbox) {
                    child.userData.linkedTower = entry;
                }
            });

            // Spend money
            spendMoney(towerCost);
            showError(`Placed ${selectedTower.toUpperCase()} (-$${towerCost})`);

            // AUTO-UNEQUIP after valid placement
            selectedTower = null;
            ghostRing.visible = false;

            // Reset UI buttons
            const buttons = [btnBasic, btnSniper, btnScout, btnPyro, btnTesla];
            buttons.forEach(b => b.style.borderColor = '#555');
        }

        // Raycaster for clicks
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Prevent context menu
        // Prevent context menu (Right Click) & Cancel Build
        window.addEventListener('contextmenu', e => {
            e.preventDefault();
            if (selectedTower) {
                selectedTower = null;
                ghostRing.visible = false;
                // Reset UI
                const buttons = [btnBasic, btnSniper, btnScout, btnPyro, btnTesla];
                buttons.forEach(b => b.style.borderColor = '#555');
            }
        });

        let isDragging = false;
        let mouseDownPos = new THREE.Vector2();

        window.addEventListener('pointerdown', (event) => {
            if (event.target.tagName === 'BUTTON') return;
            mouseDownPos.set(event.clientX, event.clientY);
            isDragging = false;
        });

        window.addEventListener('pointermove', (event) => {
            const dist = mouseDownPos.distanceTo(new THREE.Vector2(event.clientX, event.clientY));
            if (dist > 5) isDragging = true;

            // Ghost Ring Update
            if (selectedTower) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                // Raycast against ground for ghost
                const intersects = raycaster.intersectObjects([groundPlane, ...terrainObjects]);
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    // Snap
                    const snapX = Math.round(hit.point.x / TILE_SIZE) * TILE_SIZE;
                    const snapZ = Math.round(hit.point.z / TILE_SIZE) * TILE_SIZE;
                    let y = hit.point.y;
                    if (hit.object.userData.isTerrain) y = hit.object.userData.height;

                    updateGhost(snapX, snapZ);
                    ghostRing.position.y = y + 0.2;
                }
            }
        });

        window.addEventListener('pointerup', (event) => {
            if (isDragging) return;
            if (event.button !== 0) return;
            if (event.target.tagName === 'BUTTON') return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // 1. Check if clicked on EXISTING TOWER (Mesh check)
            // ONLY if NOT building (selectedTower is null)
            let hitTower = null;

            if (!selectedTower) {
                // Raycast against scene
                const allIntersects = raycaster.intersectObjects(scene.children, true);

                // Find first tower hit
                for (let i = 0; i < allIntersects.length; i++) {
                    const obj = allIntersects[i].object;

                    // Check if it's a hitbox
                    if (obj.userData.isHitbox) {
                        showDebug("HITBOX CLICKED");

                        // Try explicit link first
                        if (obj.userData.linkedTower) {
                            hitTower = obj.userData.linkedTower;
                            showDebug("TOWER FOUND (LINK)");
                            break;
                        }

                        // Traverse UP to find tower mesh (hitbox -> group -> might be tower)
                        let searchParent = obj.parent;
                        while (searchParent) {
                            const found = towers.find(t => t.mesh === searchParent);
                            if (found) {
                                hitTower = found;
                                showDebug("TOWER FOUND (PARENT SEARCH)");
                                break;
                            }
                            searchParent = searchParent.parent;
                            if (searchParent === scene) break;
                        }

                        if (hitTower) break;
                        showDebug("NO TOWER DATA - CHECK LINKAGE");
                        continue; // Skip non-hitbox fallback for this object
                    }

                    // Fallback: non-hitbox parts of tower
                    let current = obj;
                    while (current) {
                        const towerObj = towers.find(t => t.mesh === current);
                        if (towerObj) {
                            hitTower = towerObj;
                            showDebug("TOWER FOUND (MESH SEARCH)");
                            break;
                        }
                        current = current.parent;
                        if (current === scene) break;
                    }
                    if (hitTower) break;
                }
            }

            if (hitTower) {
                showDebug("OPENING UI...");
                showDebug("Step 1: Set selectedPlacedTower");
                // SELECT TOWER
                selectedPlacedTower = hitTower;
                showDebug("Step 2: Clear selectedTower");
                selectedTower = null; // Exit placement mode checks
                showDebug("Step 3: About to set panel style");

                // Show Stats - FORCED
                uiPanel.style.display = 'block';
                showDebug("Step 4: display=block done");
                uiPanel.style.visibility = 'visible';
                showDebug("Step 5: visibility=visible done");
                uiPanel.style.opacity = '1';
                showDebug("Step 6: opacity=1 done");

                showDebug("PANEL SHOULD BE VISIBLE NOW");

                uiName.textContent = hitTower.type.toUpperCase();
                uiRange.textContent = hitTower.range;
                uiSpeed.textContent = hitTower.maxCooldown * (1000 / 60) + "ms"; // approx
                uiDamage.textContent = hitTower.damage; // Now dynamic
                uiKills.textContent = hitTower.kills || 0;

                // Show Ring
                selectionRing.visible = true;
                selectionRing.position.copy(hitTower.mesh.position);
                selectionRing.position.y = hitTower.mesh.position.y - 1.5 + 0.1; // Base level
                if (hitTower.type === 'scout') selectionRing.position.y = hitTower.mesh.position.y + 0.1; // Scouts are at 0 origin

                selectionRing.scale.set(hitTower.range, hitTower.range, 1);

                return;
            }

            // 2. If no tower hit, try PLACE TOWER (if mode active)
            if (selectedTower) {
                const objectsToCheck = [groundPlane, ...terrainObjects];
                const intersects = raycaster.intersectObjects(objectsToCheck);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const point = hit.point;
                    let groundY = 0;
                    if (hit.object.userData.isTerrain) groundY = hit.object.userData.height;

                    placeTower(point.x, point.z, groundY);
                }
            } else {
                // Clicked empty space: Deselect
                selectedPlacedTower = null;
                // uiPanel.style.display = 'none'; // DEBUG: Commented out to see if this is checking
                selectionRing.visible = false;
            }
        });

        // Projectiles array
        // const projectiles = []; // Removed duplicate declaration

        // Projectiles
        function createProjectile(start, targetPos) {
            const geom = new THREE.SphereGeometry(0.2, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(start);
            scene.add(mesh);

            projectiles.push({
                mesh: mesh,
                target: targetPos, // Store the target position, not the enemy object
                speed: 1.0,
                active: true
            });
        }

        // document.getElementById('spawnBtn').addEventListener('click', spawnEnemy); // Replaced by Wave System

        // --- LOOP ---

        // Initialize ghostRing
        // let ghostRing = createRangeRing(1, 0xffffff); // REMOVED DUPLICATE

        // We need to add it to scene AFTER scene is created, which is done above.
        // Wait, scene is created in the previous block. We should make sure ghostRing is added.
        scene.add(ghostRing);
        ghostRing.visible = false;

        // ... (logic) ...

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Enemy Logic
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (!enemy.active) continue;

                // Regeneration mutation
                if (enemy.regenRate && enemy.hp < enemy.maxHp) {
                    enemy.hp = Math.min(enemy.maxHp, enemy.hp + enemy.regenRate / 60); // Per frame
                }

                // Move towards next node
                const target = pathNodes[enemy.nodeIndex + 1];
                if (!target) {
                    // Reached end
                    enemy.active = false;
                    scene.remove(enemy.mesh);
                    enemies.splice(i, 1);
                    // Lives --? (TODO: Add lives)
                    continue;
                }

                const dir = new THREE.Vector3().subVectors(target, enemy.mesh.position).normalize();
                dir.y = 0; // Keep horizontal movement only
                const dist = enemy.mesh.position.distanceTo(new THREE.Vector3(target.x, enemy.mesh.position.y, target.z));

                if (dist < 0.2) {
                    enemy.nodeIndex++;
                    if (enemy.nodeIndex >= pathNodes.length - 1) {
                        enemy.active = false;
                        scene.remove(enemy.mesh);
                        enemies.splice(i, 1);
                    }
                } else {
                    enemy.mesh.position.add(dir.multiplyScalar(enemy.speed));
                }

                // Maintain flying height
                if (enemy.isFlying) {
                    enemy.mesh.position.y = enemy.baseY;
                }
            }

            // --- WAVE SYSTEM UPDATE ---
            if (waveState === 'SPAWNING') {
                if (spawnTimer > 0) {
                    spawnTimer--;
                } else {
                    spawnEnemy();
                    enemiesToSpawn--;
                    spawnTimer = TIME_BETWEEN_SPAWNS;

                    if (enemiesToSpawn <= 0) {
                        waveState = 'ACTIVE';
                    }
                }
            } else if (waveState === 'ACTIVE') {
                // Check if all enemies dead
                if (enemies.length === 0) {
                    waveState = 'COOLDOWN';
                    waveCooldown = TIME_BETWEEN_WAVES;

                    // Wave completion bonus
                    const waveBonus = 50 + (wave * 10);
                    addMoney(waveBonus);
                    showError(`Wave Cleared! +$${waveBonus} Bonus!`);
                }
            } else if (waveState === 'COOLDOWN') {
                if (waveCooldown > 0) {
                    waveCooldown--;
                } else {
                    // NEXT WAVE
                    wave++;
                    startWave();
                }
            }

            // Tower Logic (Shooting)
            towers.forEach(t => {
                if (t.cooldown > 0) t.cooldown--;
                else {
                    // Find target
                    let target = null;
                    let minDist = t.range;

                    for (const e of enemies) {
                        // Flying enemies can only be hit by Tesla towers
                        if (e.isFlying && t.type !== 'tesla') continue;

                        const dist = t.mesh.position.distanceTo(e.mesh.position);
                        if (dist < minDist) {
                            minDist = dist;
                            target = e;
                        }
                    }

                    if (target) {
                        t.cooldown = t.maxCooldown;

                        // Look at Target (Y-axis only)
                        t.mesh.lookAt(target.mesh.position.x, t.mesh.position.y, target.mesh.position.z);

                        // PLAY SOUND
                        playSound(t.type);

                        // Create Projectile (Standard)
                        if (t.type !== 'pyro' && t.type !== 'tesla') {
                            createProjectile(t.mesh.position.clone().add(new THREE.Vector3(0, 3, 0)), target.mesh.position);
                        }

                        // VISUAL EFFECTS & SPECIAL LOGIC

                        // Sniper Tracer
                        if (t.type === 'sniper') {
                            const laserGeom = new THREE.BufferGeometry().setFromPoints([
                                t.mesh.position.clone().add(new THREE.Vector3(0, 3, 0)),
                                target.mesh.position
                            ]);
                            const laserMat = new THREE.LineBasicMaterial({ color: 0xffaa00 });
                            const laser = new THREE.Line(laserGeom, laserMat);
                            scene.add(laser);
                            setTimeout(() => scene.remove(laser), 50);
                        }

                        // Pyromancer Flame
                        if (t.type === 'pyro') {
                            // Draw a thicker orange line
                            /* 
                                Ideally particles, but line is easier for single file. 
                            */
                            const laserGeom = new THREE.BufferGeometry().setFromPoints([
                                t.mesh.position.clone().add(new THREE.Vector3(0.6, 2.7, 0.7)), // Staff tip
                                target.mesh.position
                            ]);
                            const laserMat = new THREE.LineBasicMaterial({ color: 0xff4400, linewidth: 3 });
                            const laser = new THREE.Line(laserGeom, laserMat);
                            scene.add(laser);
                            setTimeout(() => scene.remove(laser), 40); // Fast fade for flicker
                        }

                        // Tesla Lightning
                        if (t.type === 'tesla') {
                            const bolts = [];
                            bolts.push(target);

                            // Find targets near the main target (Chain)
                            // Level 1: 2 extra (3 total)
                            // Level 2: 3 extra (4 total)
                            // Level 3: 4 extra (5 total)
                            const chainLimit = 1 + (t.level || 1);
                            const chainRange = 8; // Units to chain lightning
                            let chainCount = 0;
                            for (const e of enemies) {
                                if (chainCount >= chainLimit) break;
                                if (e === target) continue;
                                if (e.mesh.position.distanceTo(target.mesh.position) < chainRange) {
                                    bolts.push(e);
                                    // Deal damage to chained
                                    e.hp -= (t.damage * 0.5); // Half dmg to bounce
                                    if (e.hp <= 0 && e.active) {
                                        e.active = false;
                                        scene.remove(e.mesh);
                                        const idx = enemies.indexOf(e);
                                        if (idx > -1) enemies.splice(idx, 1);
                                        t.kills++;
                                    }
                                    chainCount++;
                                }
                            }

                            // Draw ZigZags
                            const startPos = t.mesh.position.clone().add(new THREE.Vector3(0, 2.5, 0));
                            let prevPos = startPos;

                            bolts.forEach(boltTarget => {
                                const endPos = boltTarget.mesh.position;

                                // Simple Line for now (Zigzag is complex for 1 tool call)
                                const geom = new THREE.BufferGeometry().setFromPoints([prevPos, endPos]);
                                const mat = new THREE.LineBasicMaterial({ color: 0x00ffff });
                                const line = new THREE.Line(geom, mat);
                                scene.add(line);
                                setTimeout(() => scene.remove(line), 100);

                                prevPos = endPos;
                            });
                        }

                        // Damage Logic (Main Target)
                        // Apply damage reduction for Loaded mutation
                        let finalDamage = t.damage;
                        if (target.damageReduction) {
                            finalDamage = t.damage * (1 - target.damageReduction);
                        }
                        target.hp -= finalDamage;
                        if (target.hp <= 0) {
                            target.active = false;
                            scene.remove(target.mesh);
                            const idx = enemies.indexOf(target);
                            if (idx > -1) enemies.splice(idx, 1);

                            t.kills++;
                            if (selectedPlacedTower === t) {
                                uiKills.textContent = t.kills;
                            }

                            // Money reward based on enemy type
                            let reward = 5 + Math.floor(wave * 0.5); // Base reward scales with wave
                            if (target.type && target.type.includes('giant')) reward *= 3;
                            if (target.type && target.type.includes('boss')) reward *= 10;
                            if (target.type && target.type.includes('molten')) reward *= 1.5;
                            if (target.type && target.type.includes('frozen')) reward *= 2;
                            if (target.type && target.type.includes('void')) reward *= 2.5;
                            if (target.type && target.type.includes('heavenly')) reward *= 3;
                            addMoney(Math.floor(reward));
                        }
                    }
                }
            });

            // Update Counter
            document.getElementById('enemyCountDisplay').textContent = `Enemies: ${enemies.length}`;

            // Update Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (!p.active) continue;

                const dir = new THREE.Vector3().subVectors(p.target, p.mesh.position).normalize();
                p.mesh.position.add(dir.multiplyScalar(2.0)); // Fast speed

                if (p.mesh.position.distanceTo(p.target) < 1.0) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }

            composer.render();
        }

        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>